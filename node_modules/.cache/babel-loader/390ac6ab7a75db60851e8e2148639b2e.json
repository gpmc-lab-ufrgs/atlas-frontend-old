{"ast":null,"code":"import _isPlainObject from \"lodash/isPlainObject\";\nimport _isFunction from \"lodash/isFunction\";\nimport _includes from \"lodash/includes\";\nimport * as Helpers from \"./helpers\";\nimport * as Collection from \"./collection\";\nimport * as d3Scale from \"victory-vendor/d3-scale\";\nvar supportedScaleStrings = [\"linear\", \"time\", \"log\", \"sqrt\"]; // Private Functions\n\nfunction toNewName(scale) {\n  // d3 scale changed the naming scheme for scale from \"linear\" -> \"scaleLinear\" etc.\n  var capitalize = function (s) {\n    return s && s[0].toUpperCase() + s.slice(1);\n  };\n\n  return \"scale\".concat(capitalize(scale));\n}\n\nfunction validScale(scale) {\n  if (typeof scale === \"function\") {\n    return _isFunction(scale.copy) && _isFunction(scale.domain) && _isFunction(scale.range);\n  } else if (typeof scale === \"string\") {\n    return _includes(supportedScaleStrings, scale);\n  }\n\n  return false;\n}\n\nfunction isScaleDefined(props, axis) {\n  if (!props.scale) {\n    return false;\n  } else if (props.scale.x || props.scale.y) {\n    return props.scale[axis] ? true : false;\n  }\n\n  return true;\n}\n\nfunction getScaleTypeFromProps(props, axis) {\n  if (!isScaleDefined(props, axis)) {\n    return undefined;\n  }\n\n  var scale = props.scale[axis] || props.scale;\n  return typeof scale === \"string\" ? scale : getType(scale);\n}\n\nfunction getScaleFromDomain(props, axis) {\n  var domain;\n\n  if (props.domain && props.domain[axis]) {\n    domain = props.domain[axis];\n  } else if (props.domain && Array.isArray(props.domain)) {\n    domain = props.domain;\n  }\n\n  if (!domain) {\n    return undefined;\n  }\n\n  return Collection.containsDates(domain) ? \"time\" : \"linear\";\n}\n\nfunction getScaleTypeFromData(props, axis) {\n  if (!props.data) {\n    return \"linear\";\n  }\n\n  var accessor = Helpers.createAccessor(props[axis]);\n  var axisData = props.data.map(function (datum) {\n    var processedData = _isPlainObject(accessor(datum)) ? accessor(datum)[axis] : accessor(datum);\n    return processedData !== undefined ? processedData : datum[axis];\n  });\n  return Collection.containsDates(axisData) ? \"time\" : \"linear\";\n} // Exported Functions\n\n\nexport function getScaleFromName(name) {\n  return validScale(name) ? d3Scale[toNewName(name)]() : d3Scale.scaleLinear();\n}\nexport function getBaseScale(props, axis) {\n  var scale = getScaleFromProps(props, axis);\n\n  if (scale) {\n    return typeof scale === \"string\" ? getScaleFromName(scale) : scale;\n  }\n\n  var defaultScale = getScaleFromDomain(props, axis) || getScaleTypeFromData(props, axis);\n  return d3Scale[toNewName(defaultScale)]();\n}\nexport function getDefaultScale() {\n  return d3Scale.scaleLinear();\n}\nexport function getScaleFromProps(props, axis) {\n  if (!isScaleDefined(props, axis)) {\n    return undefined;\n  }\n\n  var scale = props.scale[axis] || props.scale;\n\n  if (validScale(scale)) {\n    return _isFunction(scale) ? scale : d3Scale[toNewName(scale)]();\n  }\n\n  return undefined;\n}\nexport function getScaleType(props, axis) {\n  // if the scale was not given in props, it will be set to linear or time depending on data\n  return getScaleTypeFromProps(props, axis) || getScaleTypeFromData(props, axis);\n} // Ordered type inference off of function fields.\n// **Note**: Brittle because reliant on d3 internals.\n\nvar DUCK_TYPES = [{\n  name: \"quantile\",\n  method: \"quantiles\"\n}, {\n  name: \"log\",\n  method: \"base\"\n} // TODO(2214): Re-evaluate (1) duck typing approach, and (2) if duck typing,\n//   do we need a different approach? (Multiple keys? Stringifying functions?)\n// https://github.com/FormidableLabs/victory/issues/2214\n// Below are matches that don't seem to otherwise occur in Victory code base.\n// { name: \"ordinal\", method: \"unknown\" },\n// { name: \"pow-sqrt\", method: \"exponent\" },\n// { name: \"quantize-threshold\", method: \"invertExtent\" }\n];\nexport function getType(scale) {\n  if (typeof scale === \"string\") {\n    return scale;\n  }\n\n  var scaleType = DUCK_TYPES.filter(function (type) {\n    return scale[type.method] !== undefined;\n  })[0];\n  return scaleType ? scaleType.name : undefined;\n}","map":{"version":3,"names":["_isPlainObject","_isFunction","_includes","Helpers","Collection","d3Scale","supportedScaleStrings","toNewName","scale","capitalize","s","toUpperCase","slice","concat","validScale","copy","domain","range","isScaleDefined","props","axis","x","y","getScaleTypeFromProps","undefined","getType","getScaleFromDomain","Array","isArray","containsDates","getScaleTypeFromData","data","accessor","createAccessor","axisData","map","datum","processedData","getScaleFromName","name","scaleLinear","getBaseScale","getScaleFromProps","defaultScale","getDefaultScale","getScaleType","DUCK_TYPES","method","scaleType","filter","type"],"sources":["/Users/leonardogomes/Documents/atlas/atlas/node_modules/victory-core/es/victory-util/scale.js"],"sourcesContent":["import _isPlainObject from \"lodash/isPlainObject\";\nimport _isFunction from \"lodash/isFunction\";\nimport _includes from \"lodash/includes\";\nimport * as Helpers from \"./helpers\";\nimport * as Collection from \"./collection\";\nimport * as d3Scale from \"victory-vendor/d3-scale\";\nvar supportedScaleStrings = [\"linear\", \"time\", \"log\", \"sqrt\"]; // Private Functions\n\nfunction toNewName(scale) {\n  // d3 scale changed the naming scheme for scale from \"linear\" -> \"scaleLinear\" etc.\n  var capitalize = function (s) {\n    return s && s[0].toUpperCase() + s.slice(1);\n  };\n\n  return \"scale\".concat(capitalize(scale));\n}\n\nfunction validScale(scale) {\n  if (typeof scale === \"function\") {\n    return _isFunction(scale.copy) && _isFunction(scale.domain) && _isFunction(scale.range);\n  } else if (typeof scale === \"string\") {\n    return _includes(supportedScaleStrings, scale);\n  }\n\n  return false;\n}\n\nfunction isScaleDefined(props, axis) {\n  if (!props.scale) {\n    return false;\n  } else if (props.scale.x || props.scale.y) {\n    return props.scale[axis] ? true : false;\n  }\n\n  return true;\n}\n\nfunction getScaleTypeFromProps(props, axis) {\n  if (!isScaleDefined(props, axis)) {\n    return undefined;\n  }\n\n  var scale = props.scale[axis] || props.scale;\n  return typeof scale === \"string\" ? scale : getType(scale);\n}\n\nfunction getScaleFromDomain(props, axis) {\n  var domain;\n\n  if (props.domain && props.domain[axis]) {\n    domain = props.domain[axis];\n  } else if (props.domain && Array.isArray(props.domain)) {\n    domain = props.domain;\n  }\n\n  if (!domain) {\n    return undefined;\n  }\n\n  return Collection.containsDates(domain) ? \"time\" : \"linear\";\n}\n\nfunction getScaleTypeFromData(props, axis) {\n  if (!props.data) {\n    return \"linear\";\n  }\n\n  var accessor = Helpers.createAccessor(props[axis]);\n  var axisData = props.data.map(function (datum) {\n    var processedData = _isPlainObject(accessor(datum)) ? accessor(datum)[axis] : accessor(datum);\n    return processedData !== undefined ? processedData : datum[axis];\n  });\n  return Collection.containsDates(axisData) ? \"time\" : \"linear\";\n} // Exported Functions\n\n\nexport function getScaleFromName(name) {\n  return validScale(name) ? d3Scale[toNewName(name)]() : d3Scale.scaleLinear();\n}\nexport function getBaseScale(props, axis) {\n  var scale = getScaleFromProps(props, axis);\n\n  if (scale) {\n    return typeof scale === \"string\" ? getScaleFromName(scale) : scale;\n  }\n\n  var defaultScale = getScaleFromDomain(props, axis) || getScaleTypeFromData(props, axis);\n  return d3Scale[toNewName(defaultScale)]();\n}\nexport function getDefaultScale() {\n  return d3Scale.scaleLinear();\n}\nexport function getScaleFromProps(props, axis) {\n  if (!isScaleDefined(props, axis)) {\n    return undefined;\n  }\n\n  var scale = props.scale[axis] || props.scale;\n\n  if (validScale(scale)) {\n    return _isFunction(scale) ? scale : d3Scale[toNewName(scale)]();\n  }\n\n  return undefined;\n}\nexport function getScaleType(props, axis) {\n  // if the scale was not given in props, it will be set to linear or time depending on data\n  return getScaleTypeFromProps(props, axis) || getScaleTypeFromData(props, axis);\n} // Ordered type inference off of function fields.\n// **Note**: Brittle because reliant on d3 internals.\n\nvar DUCK_TYPES = [{\n  name: \"quantile\",\n  method: \"quantiles\"\n}, {\n  name: \"log\",\n  method: \"base\"\n} // TODO(2214): Re-evaluate (1) duck typing approach, and (2) if duck typing,\n//   do we need a different approach? (Multiple keys? Stringifying functions?)\n// https://github.com/FormidableLabs/victory/issues/2214\n// Below are matches that don't seem to otherwise occur in Victory code base.\n// { name: \"ordinal\", method: \"unknown\" },\n// { name: \"pow-sqrt\", method: \"exponent\" },\n// { name: \"quantize-threshold\", method: \"invertExtent\" }\n];\nexport function getType(scale) {\n  if (typeof scale === \"string\") {\n    return scale;\n  }\n\n  var scaleType = DUCK_TYPES.filter(function (type) {\n    return scale[type.method] !== undefined;\n  })[0];\n  return scaleType ? scaleType.name : undefined;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}