{"ast":null,"code":"import _omitBy from \"lodash/omitBy\";\nimport _isUndefined from \"lodash/isUndefined\";\nimport _includes from \"lodash/includes\";\nimport _isEqual from \"lodash/isEqual\";\nimport _isEmpty from \"lodash/isEmpty\";\nimport _orderBy from \"lodash/orderBy\";\nimport _property from \"lodash/property\";\nimport _isPlainObject from \"lodash/isPlainObject\";\nimport _isFunction from \"lodash/isFunction\";\nimport _last from \"lodash/last\";\nimport _range from \"lodash/range\";\nimport _uniq from \"lodash/uniq\";\nimport _assign from \"lodash/assign\";\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n/* eslint-disable func-style */\n\n/* eslint-disable no-use-before-define */\n\n\nimport React from \"react\";\nimport * as Helpers from \"./helpers\";\nimport * as Collection from \"./collection\";\nimport * as Scale from \"./scale\";\nimport * as Immutable from \"./immutable\"; // Private Functions\n\nfunction parseDatum(datum) {\n  var immutableDatumWhitelist = {\n    errorX: true,\n    errorY: true\n  };\n  return Immutable.isImmutable(datum) ? Immutable.shallowToJS(datum, immutableDatumWhitelist) : datum;\n}\n\nfunction getLength(data) {\n  return Immutable.isIterable(data) ? data.size : data.length;\n} // Returns generated data for a given axis based on domain and sample from props\n\n\nfunction generateDataArray(props, axis) {\n  var propsDomain = _isPlainObject(props.domain) ? props.domain[axis] : props.domain;\n  var domain = propsDomain || Scale.getBaseScale(props, axis).domain();\n  var samples = props.samples || 1;\n  var domainMax = Math.max.apply(Math, _toConsumableArray(domain));\n  var domainMin = Math.min.apply(Math, _toConsumableArray(domain));\n  var step = (domainMax - domainMin) / samples;\n\n  var values = _range(domainMin, domainMax, step);\n\n  return _last(values) === domainMax ? values : values.concat(domainMax);\n} // Returns sorted data. If no sort keys are provided, data is returned unaltered.\n\n\nfunction sortData(dataset, sortKey) {\n  var sortOrder = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"ascending\";\n\n  if (!sortKey) {\n    return dataset;\n  } // Ensures previous VictoryLine api for sortKey prop stays consistent\n\n\n  if (sortKey === \"x\" || sortKey === \"y\") {\n    sortKey = \"_\".concat(sortKey);\n  }\n\n  var order = sortOrder === \"ascending\" ? \"asc\" : \"desc\";\n  return _orderBy(dataset, sortKey, order);\n} // This method will remove data points that break certain scales. (log scale only)\n\n\nfunction cleanData(dataset, props) {\n  var smallNumber = 1 / Number.MAX_SAFE_INTEGER;\n  var scaleType = {\n    x: Scale.getScaleType(props, \"x\"),\n    y: Scale.getScaleType(props, \"y\")\n  };\n\n  if (scaleType.x !== \"log\" && scaleType.y !== \"log\") {\n    return dataset;\n  }\n\n  var rules = function (datum, axis) {\n    return scaleType[axis] === \"log\" ? datum[\"_\".concat(axis)] !== 0 : true;\n  };\n\n  var sanitize = function (datum) {\n    var _x = rules(datum, \"x\") ? datum._x : smallNumber;\n\n    var _y = rules(datum, \"y\") ? datum._y : smallNumber;\n\n    var _y0 = rules(datum, \"y0\") ? datum._y0 : smallNumber;\n\n    return _assign({}, datum, {\n      _x: _x,\n      _y: _y,\n      _y0: _y0\n    });\n  };\n\n  return dataset.map(function (datum) {\n    if (rules(datum, \"x\") && rules(datum, \"y\") && rules(datum, \"y0\")) {\n      return datum;\n    }\n\n    return sanitize(datum);\n  });\n} // Returns a data accessor given an eventKey prop\n\n\nfunction getEventKey(key) {\n  // creates a data accessor function\n  // given a property key, path, array index, or null for identity.\n  if (_isFunction(key)) {\n    return key;\n  } else if (key === null || key === undefined) {\n    return function () {\n      return undefined;\n    };\n  } // otherwise, assume it is an array index, property key or path (_.property handles all three)\n\n\n  return _property(key);\n} // Returns data with an eventKey prop added to each datum\n\n\nfunction addEventKeys(props, data) {\n  var hasEventKeyAccessor = !!props.eventKey;\n  var eventKeyAccessor = getEventKey(props.eventKey);\n  return data.map(function (datum, index) {\n    if (datum.eventKey !== undefined) {\n      return datum;\n    } else if (hasEventKeyAccessor) {\n      var eventKey = eventKeyAccessor(datum, index);\n      return eventKey !== undefined ? _assign({\n        eventKey: eventKey\n      }, datum) : datum;\n    } else {\n      return datum;\n    }\n  });\n} // Exported Functions\n// This method will remove data points that fall outside of the desired domain (non-continuous charts only)\n\n\nexport function formatDataFromDomain(dataset, domain, defaultBaseline) {\n  var exists = function (val) {\n    return val !== undefined;\n  };\n\n  var minDomainX = Collection.getMinValue(domain.x);\n  var maxDomainX = Collection.getMaxValue(domain.x);\n  var minDomainY = Collection.getMinValue(domain.y);\n  var maxDomainY = Collection.getMaxValue(domain.y);\n\n  var underMin = function (min) {\n    return function (val) {\n      return exists(val) && val < min;\n    };\n  };\n\n  var overMax = function (max) {\n    return function (val) {\n      return exists(val) && val > max;\n    };\n  };\n\n  var isUnderMinX = underMin(minDomainX);\n  var isUnderMinY = underMin(minDomainY);\n  var isOverMaxX = overMax(maxDomainX);\n  var isOverMaxY = overMax(maxDomainY); // eslint-disable-next-line complexity\n\n  return dataset.map(function (datum) {\n    var _x = datum._x,\n        _y = datum._y,\n        _y0 = datum._y0,\n        _y1 = datum._y1; // single x point less than min domain\n\n    if (isUnderMinX(_x) || isOverMaxX(_x)) _x = null;\n    var baseline = exists(_y0) ? _y0 : defaultBaseline;\n    var value = exists(_y1) ? _y1 : _y;\n    if (!exists(value)) return datum; // value only and less than min domain or greater than max domain\n\n    if (!exists(baseline) && (isUnderMinY(value) || isOverMaxY(value))) _y = null; // baseline and value are both less than min domain or both greater than max domain\n\n    if (isUnderMinY(baseline) && isUnderMinY(value) || isOverMaxY(baseline) && isOverMaxY(value)) _y = _y0 = _y1 = null; // baseline and value with only baseline below min, set baseline to minDomainY\n\n    if (isUnderMinY(baseline) && !isUnderMinY(value)) _y0 = minDomainY; // baseline and value with only baseline above max, set baseline to maxDomainY\n\n    if (isOverMaxY(baseline) && !isOverMaxY(value)) _y0 = maxDomainY;\n    return _assign({}, datum, _omitBy({\n      _x: _x,\n      _y: _y,\n      _y0: _y0,\n      _y1: _y1\n    }, _isUndefined));\n  });\n}\n/**\n * Returns an object mapping string data to numeric data\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Object} an object mapping string data to numeric data\n */\n\nexport function createStringMap(props, axis) {\n  var stringsFromAxes = getStringsFromAxes(props, axis);\n  var stringsFromCategories = getStringsFromCategories(props, axis);\n  var stringsFromData = getStringsFromData(props, axis);\n\n  var allStrings = _uniq([].concat(_toConsumableArray(stringsFromAxes), _toConsumableArray(stringsFromCategories), _toConsumableArray(stringsFromData)));\n\n  return allStrings.length === 0 ? null : allStrings.reduce(function (memo, string, index) {\n    memo[string] = index + 1;\n    return memo;\n  }, {});\n}\n/**\n * Reduces the size of a data array, such that it is <= maxPoints.\n * @param {Array} data: an array of data; must be sorted\n * @param {Number} maxPoints: maximum number of data points to return\n * @param {Number} startingIndex: the index of the data[0] *in the entire dataset*; this function\n                   assumes `data` param is a subset of larger dataset that has been zoommed\n  * @returns {Array} an array of data, a subset of data param\n  */\n\nexport function downsample(data, maxPoints) {\n  var startingIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0; // ensures that the downampling of data while zooming looks good.\n\n  var dataLength = getLength(data);\n\n  if (dataLength > maxPoints) {\n    // limit k to powers of 2, e.g. 64, 128, 256\n    // so that the same points will be chosen reliably, reducing flicker on zoom\n    var k = Math.pow(2, Math.ceil(Math.log2(dataLength / maxPoints)));\n    return data.filter( // ensure modulo is always calculated from same reference: i + startingIndex\n    function (d, i) {\n      return (i + startingIndex) % k === 0;\n    });\n  }\n\n  return data;\n}\n/**\n * Returns formatted data. Data accessors are applied, and string values are replaced.\n * @param {Array} dataset: the original domain\n * @param {Object} props: the props object\n * @param {Array} expectedKeys: an array of expected data keys\n * @returns {Array} the formatted data\n */\n\nexport function formatData(dataset, props, expectedKeys) {\n  var isArrayOrIterable = Array.isArray(dataset) || Immutable.isIterable(dataset);\n\n  if (!isArrayOrIterable || getLength(dataset) < 1) {\n    return [];\n  }\n\n  var defaultKeys = [\"x\", \"y\", \"y0\"];\n  expectedKeys = Array.isArray(expectedKeys) ? expectedKeys : defaultKeys;\n\n  var createAccessor = function (name) {\n    return Helpers.createAccessor(props[name] !== undefined ? props[name] : name);\n  };\n\n  var accessor = expectedKeys.reduce(function (memo, type) {\n    memo[type] = createAccessor(type);\n    return memo;\n  }, {});\n  var preformattedData = _isEqual(expectedKeys, defaultKeys) && props.x === \"_x\" && props.y === \"_y\" && props.y0 === \"_y0\";\n  var stringMap;\n\n  if (preformattedData === false) {\n    // stringMap is not required if the data is preformatted\n    stringMap = {\n      x: expectedKeys.indexOf(\"x\") !== -1 ? createStringMap(props, \"x\") : undefined,\n      y: expectedKeys.indexOf(\"y\") !== -1 ? createStringMap(props, \"y\") : undefined,\n      y0: expectedKeys.indexOf(\"y0\") !== -1 ? createStringMap(props, \"y\") : undefined\n    };\n  }\n\n  var data = preformattedData ? dataset : dataset.reduce(function (dataArr, datum, index) {\n    // eslint-disable-line complexity\n    datum = parseDatum(datum);\n    var fallbackValues = {\n      x: index,\n      y: datum\n    };\n    var processedValues = expectedKeys.reduce(function (memo, type) {\n      var processedValue = accessor[type](datum);\n      var value = processedValue !== undefined ? processedValue : fallbackValues[type];\n\n      if (value !== undefined) {\n        if (typeof value === \"string\" && stringMap[type]) {\n          memo[\"\".concat(type, \"Name\")] = value;\n          memo[\"_\".concat(type)] = stringMap[type][value];\n        } else {\n          memo[\"_\".concat(type)] = value;\n        }\n      }\n\n      return memo;\n    }, {});\n\n    var formattedDatum = _assign({}, processedValues, datum);\n\n    if (!_isEmpty(formattedDatum)) {\n      dataArr.push(formattedDatum);\n    }\n\n    return dataArr;\n  }, []);\n  var sortedData = sortData(data, props.sortKey, props.sortOrder);\n  var cleanedData = cleanData(sortedData, props);\n  return addEventKeys(props, cleanedData);\n}\n/**\n * Returns generated x and y data based on domain and sample from props\n * @param {Object} props: the props object\n * @returns {Array} an array of data\n */\n\nexport function generateData(props) {\n  var xValues = generateDataArray(props, \"x\");\n  var yValues = generateDataArray(props, \"y\");\n  var values = xValues.map(function (x, i) {\n    return {\n      x: x,\n      y: yValues[i]\n    };\n  });\n  return values;\n}\n/**\n * Returns an array of categories for a given axis\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} an array of categories\n */\n\nexport function getCategories(props, axis) {\n  return props.categories && !Array.isArray(props.categories) ? props.categories[axis] : props.categories;\n}\n/**\n * Returns an array of formatted data\n * @param {Object} props: the props object\n * @returns {Array} an array of data\n */\n\nexport function getData(props) {\n  return props.data ? formatData(props.data, props) : formatData(generateData(props), props);\n}\n/**\n * Returns an array of strings from axis tickValues for a given axis\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} an array of strings\n */\n\nexport function getStringsFromAxes(props, axis) {\n  var tickValues = props.tickValues,\n      tickFormat = props.tickFormat;\n  var tickValueArray;\n\n  if (!tickValues || !Array.isArray(tickValues) && !tickValues[axis]) {\n    tickValueArray = tickFormat && Array.isArray(tickFormat) ? tickFormat : [];\n  } else {\n    tickValueArray = tickValues[axis] || tickValues;\n  }\n\n  return tickValueArray.filter(function (val) {\n    return typeof val === \"string\";\n  });\n}\n/**\n * Returns an array of strings from categories for a given axis\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} an array of strings\n */\n\nexport function getStringsFromCategories(props, axis) {\n  if (!props.categories) {\n    return [];\n  }\n\n  var categories = getCategories(props, axis);\n  var categoryStrings = categories && categories.filter(function (val) {\n    return typeof val === \"string\";\n  });\n  return categoryStrings ? Collection.removeUndefined(categoryStrings) : [];\n}\n/**\n * Returns an array of strings from data\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} an array of strings\n */\n\nexport function getStringsFromData(props, axis) {\n  var isArrayOrIterable = Array.isArray(props.data) || Immutable.isIterable(props.data);\n\n  if (!isArrayOrIterable) {\n    return [];\n  }\n\n  var key = props[axis] === undefined ? axis : props[axis];\n  var accessor = Helpers.createAccessor(key); // support immutable data\n\n  var data = props.data.reduce(function (memo, d) {\n    memo.push(parseDatum(d));\n    return memo;\n  }, []);\n  var sortedData = sortData(data, props.sortKey, props.sortOrder);\n  var dataStrings = sortedData.reduce(function (dataArr, datum) {\n    datum = parseDatum(datum);\n    dataArr.push(accessor(datum));\n    return dataArr;\n  }, []).filter(function (datum) {\n    return typeof datum === \"string\";\n  }); // return a unique set of strings\n\n  return dataStrings.reduce(function (prev, curr) {\n    if (curr !== undefined && curr !== null && prev.indexOf(curr) === -1) {\n      prev.push(curr);\n    }\n\n    return prev;\n  }, []);\n}\n/**\n * Checks whether a given component can be used to calculate data\n * @param {Component} component: a React component instance\n * @returns {Boolean} Returns true if the given component has a role included in the whitelist\n */\n\nexport function isDataComponent(component) {\n  var getRole = function (child) {\n    return child && child.type ? child.type.role : \"\";\n  };\n\n  var role = getRole(component);\n\n  if (role === \"portal\") {\n    var children = React.Children.toArray(component.props.children);\n    role = children.length ? getRole(children[0]) : \"\";\n  }\n\n  var whitelist = [\"area\", \"bar\", \"boxplot\", \"candlestick\", \"errorbar\", \"group\", \"histogram\", \"line\", \"pie\", \"scatter\", \"stack\", \"voronoi\"];\n  return _includes(whitelist, role);\n}","map":{"version":3,"names":["_omitBy","_isUndefined","_includes","_isEqual","_isEmpty","_orderBy","_property","_isPlainObject","_isFunction","_last","_range","_uniq","_assign","_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_unsupportedIterableToArray","_nonIterableSpread","TypeError","o","minLen","_arrayLikeToArray","n","Object","prototype","toString","call","slice","constructor","name","Array","from","test","iter","Symbol","iterator","isArray","len","length","i","arr2","React","Helpers","Collection","Scale","Immutable","parseDatum","datum","immutableDatumWhitelist","errorX","errorY","isImmutable","shallowToJS","getLength","data","isIterable","size","generateDataArray","props","axis","propsDomain","domain","getBaseScale","samples","domainMax","Math","max","apply","domainMin","min","step","values","concat","sortData","dataset","sortKey","sortOrder","arguments","undefined","order","cleanData","smallNumber","Number","MAX_SAFE_INTEGER","scaleType","x","getScaleType","y","rules","sanitize","_x","_y","_y0","map","getEventKey","key","addEventKeys","hasEventKeyAccessor","eventKey","eventKeyAccessor","index","formatDataFromDomain","defaultBaseline","exists","val","minDomainX","getMinValue","maxDomainX","getMaxValue","minDomainY","maxDomainY","underMin","overMax","isUnderMinX","isUnderMinY","isOverMaxX","isOverMaxY","_y1","baseline","value","createStringMap","stringsFromAxes","getStringsFromAxes","stringsFromCategories","getStringsFromCategories","stringsFromData","getStringsFromData","allStrings","reduce","memo","string","downsample","maxPoints","startingIndex","dataLength","k","pow","ceil","log2","filter","d","formatData","expectedKeys","isArrayOrIterable","defaultKeys","createAccessor","accessor","type","preformattedData","y0","stringMap","indexOf","dataArr","fallbackValues","processedValues","processedValue","formattedDatum","push","sortedData","cleanedData","generateData","xValues","yValues","getCategories","categories","getData","tickValues","tickFormat","tickValueArray","categoryStrings","removeUndefined","dataStrings","prev","curr","isDataComponent","component","getRole","child","role","children","Children","toArray","whitelist"],"sources":["/Users/leonardogomes/Documents/atlas/atlas/node_modules/victory-core/es/victory-util/data.js"],"sourcesContent":["import _omitBy from \"lodash/omitBy\";\nimport _isUndefined from \"lodash/isUndefined\";\nimport _includes from \"lodash/includes\";\nimport _isEqual from \"lodash/isEqual\";\nimport _isEmpty from \"lodash/isEmpty\";\nimport _orderBy from \"lodash/orderBy\";\nimport _property from \"lodash/property\";\nimport _isPlainObject from \"lodash/isPlainObject\";\nimport _isFunction from \"lodash/isFunction\";\nimport _last from \"lodash/last\";\nimport _range from \"lodash/range\";\nimport _uniq from \"lodash/uniq\";\nimport _assign from \"lodash/assign\";\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/* eslint-disable func-style */\n\n/* eslint-disable no-use-before-define */\nimport React from \"react\";\nimport * as Helpers from \"./helpers\";\nimport * as Collection from \"./collection\";\nimport * as Scale from \"./scale\";\nimport * as Immutable from \"./immutable\"; // Private Functions\n\nfunction parseDatum(datum) {\n  var immutableDatumWhitelist = {\n    errorX: true,\n    errorY: true\n  };\n  return Immutable.isImmutable(datum) ? Immutable.shallowToJS(datum, immutableDatumWhitelist) : datum;\n}\n\nfunction getLength(data) {\n  return Immutable.isIterable(data) ? data.size : data.length;\n} // Returns generated data for a given axis based on domain and sample from props\n\n\nfunction generateDataArray(props, axis) {\n  var propsDomain = _isPlainObject(props.domain) ? props.domain[axis] : props.domain;\n  var domain = propsDomain || Scale.getBaseScale(props, axis).domain();\n  var samples = props.samples || 1;\n  var domainMax = Math.max.apply(Math, _toConsumableArray(domain));\n  var domainMin = Math.min.apply(Math, _toConsumableArray(domain));\n  var step = (domainMax - domainMin) / samples;\n\n  var values = _range(domainMin, domainMax, step);\n\n  return _last(values) === domainMax ? values : values.concat(domainMax);\n} // Returns sorted data. If no sort keys are provided, data is returned unaltered.\n\n\nfunction sortData(dataset, sortKey) {\n  var sortOrder = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"ascending\";\n\n  if (!sortKey) {\n    return dataset;\n  } // Ensures previous VictoryLine api for sortKey prop stays consistent\n\n\n  if (sortKey === \"x\" || sortKey === \"y\") {\n    sortKey = \"_\".concat(sortKey);\n  }\n\n  var order = sortOrder === \"ascending\" ? \"asc\" : \"desc\";\n  return _orderBy(dataset, sortKey, order);\n} // This method will remove data points that break certain scales. (log scale only)\n\n\nfunction cleanData(dataset, props) {\n  var smallNumber = 1 / Number.MAX_SAFE_INTEGER;\n  var scaleType = {\n    x: Scale.getScaleType(props, \"x\"),\n    y: Scale.getScaleType(props, \"y\")\n  };\n\n  if (scaleType.x !== \"log\" && scaleType.y !== \"log\") {\n    return dataset;\n  }\n\n  var rules = function (datum, axis) {\n    return scaleType[axis] === \"log\" ? datum[\"_\".concat(axis)] !== 0 : true;\n  };\n\n  var sanitize = function (datum) {\n    var _x = rules(datum, \"x\") ? datum._x : smallNumber;\n\n    var _y = rules(datum, \"y\") ? datum._y : smallNumber;\n\n    var _y0 = rules(datum, \"y0\") ? datum._y0 : smallNumber;\n\n    return _assign({}, datum, {\n      _x: _x,\n      _y: _y,\n      _y0: _y0\n    });\n  };\n\n  return dataset.map(function (datum) {\n    if (rules(datum, \"x\") && rules(datum, \"y\") && rules(datum, \"y0\")) {\n      return datum;\n    }\n\n    return sanitize(datum);\n  });\n} // Returns a data accessor given an eventKey prop\n\n\nfunction getEventKey(key) {\n  // creates a data accessor function\n  // given a property key, path, array index, or null for identity.\n  if (_isFunction(key)) {\n    return key;\n  } else if (key === null || key === undefined) {\n    return function () {\n      return undefined;\n    };\n  } // otherwise, assume it is an array index, property key or path (_.property handles all three)\n\n\n  return _property(key);\n} // Returns data with an eventKey prop added to each datum\n\n\nfunction addEventKeys(props, data) {\n  var hasEventKeyAccessor = !!props.eventKey;\n  var eventKeyAccessor = getEventKey(props.eventKey);\n  return data.map(function (datum, index) {\n    if (datum.eventKey !== undefined) {\n      return datum;\n    } else if (hasEventKeyAccessor) {\n      var eventKey = eventKeyAccessor(datum, index);\n      return eventKey !== undefined ? _assign({\n        eventKey: eventKey\n      }, datum) : datum;\n    } else {\n      return datum;\n    }\n  });\n} // Exported Functions\n// This method will remove data points that fall outside of the desired domain (non-continuous charts only)\n\n\nexport function formatDataFromDomain(dataset, domain, defaultBaseline) {\n  var exists = function (val) {\n    return val !== undefined;\n  };\n\n  var minDomainX = Collection.getMinValue(domain.x);\n  var maxDomainX = Collection.getMaxValue(domain.x);\n  var minDomainY = Collection.getMinValue(domain.y);\n  var maxDomainY = Collection.getMaxValue(domain.y);\n\n  var underMin = function (min) {\n    return function (val) {\n      return exists(val) && val < min;\n    };\n  };\n\n  var overMax = function (max) {\n    return function (val) {\n      return exists(val) && val > max;\n    };\n  };\n\n  var isUnderMinX = underMin(minDomainX);\n  var isUnderMinY = underMin(minDomainY);\n  var isOverMaxX = overMax(maxDomainX);\n  var isOverMaxY = overMax(maxDomainY); // eslint-disable-next-line complexity\n\n  return dataset.map(function (datum) {\n    var _x = datum._x,\n        _y = datum._y,\n        _y0 = datum._y0,\n        _y1 = datum._y1; // single x point less than min domain\n\n    if (isUnderMinX(_x) || isOverMaxX(_x)) _x = null;\n    var baseline = exists(_y0) ? _y0 : defaultBaseline;\n    var value = exists(_y1) ? _y1 : _y;\n    if (!exists(value)) return datum; // value only and less than min domain or greater than max domain\n\n    if (!exists(baseline) && (isUnderMinY(value) || isOverMaxY(value))) _y = null; // baseline and value are both less than min domain or both greater than max domain\n\n    if (isUnderMinY(baseline) && isUnderMinY(value) || isOverMaxY(baseline) && isOverMaxY(value)) _y = _y0 = _y1 = null; // baseline and value with only baseline below min, set baseline to minDomainY\n\n    if (isUnderMinY(baseline) && !isUnderMinY(value)) _y0 = minDomainY; // baseline and value with only baseline above max, set baseline to maxDomainY\n\n    if (isOverMaxY(baseline) && !isOverMaxY(value)) _y0 = maxDomainY;\n    return _assign({}, datum, _omitBy({\n      _x: _x,\n      _y: _y,\n      _y0: _y0,\n      _y1: _y1\n    }, _isUndefined));\n  });\n}\n/**\n * Returns an object mapping string data to numeric data\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Object} an object mapping string data to numeric data\n */\n\nexport function createStringMap(props, axis) {\n  var stringsFromAxes = getStringsFromAxes(props, axis);\n  var stringsFromCategories = getStringsFromCategories(props, axis);\n  var stringsFromData = getStringsFromData(props, axis);\n\n  var allStrings = _uniq([].concat(_toConsumableArray(stringsFromAxes), _toConsumableArray(stringsFromCategories), _toConsumableArray(stringsFromData)));\n\n  return allStrings.length === 0 ? null : allStrings.reduce(function (memo, string, index) {\n    memo[string] = index + 1;\n    return memo;\n  }, {});\n}\n/**\n * Reduces the size of a data array, such that it is <= maxPoints.\n * @param {Array} data: an array of data; must be sorted\n * @param {Number} maxPoints: maximum number of data points to return\n * @param {Number} startingIndex: the index of the data[0] *in the entire dataset*; this function\n                   assumes `data` param is a subset of larger dataset that has been zoommed\n  * @returns {Array} an array of data, a subset of data param\n  */\n\nexport function downsample(data, maxPoints) {\n  var startingIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  // ensures that the downampling of data while zooming looks good.\n  var dataLength = getLength(data);\n\n  if (dataLength > maxPoints) {\n    // limit k to powers of 2, e.g. 64, 128, 256\n    // so that the same points will be chosen reliably, reducing flicker on zoom\n    var k = Math.pow(2, Math.ceil(Math.log2(dataLength / maxPoints)));\n    return data.filter( // ensure modulo is always calculated from same reference: i + startingIndex\n    function (d, i) {\n      return (i + startingIndex) % k === 0;\n    });\n  }\n\n  return data;\n}\n/**\n * Returns formatted data. Data accessors are applied, and string values are replaced.\n * @param {Array} dataset: the original domain\n * @param {Object} props: the props object\n * @param {Array} expectedKeys: an array of expected data keys\n * @returns {Array} the formatted data\n */\n\nexport function formatData(dataset, props, expectedKeys) {\n  var isArrayOrIterable = Array.isArray(dataset) || Immutable.isIterable(dataset);\n\n  if (!isArrayOrIterable || getLength(dataset) < 1) {\n    return [];\n  }\n\n  var defaultKeys = [\"x\", \"y\", \"y0\"];\n  expectedKeys = Array.isArray(expectedKeys) ? expectedKeys : defaultKeys;\n\n  var createAccessor = function (name) {\n    return Helpers.createAccessor(props[name] !== undefined ? props[name] : name);\n  };\n\n  var accessor = expectedKeys.reduce(function (memo, type) {\n    memo[type] = createAccessor(type);\n    return memo;\n  }, {});\n  var preformattedData = _isEqual(expectedKeys, defaultKeys) && props.x === \"_x\" && props.y === \"_y\" && props.y0 === \"_y0\";\n  var stringMap;\n\n  if (preformattedData === false) {\n    // stringMap is not required if the data is preformatted\n    stringMap = {\n      x: expectedKeys.indexOf(\"x\") !== -1 ? createStringMap(props, \"x\") : undefined,\n      y: expectedKeys.indexOf(\"y\") !== -1 ? createStringMap(props, \"y\") : undefined,\n      y0: expectedKeys.indexOf(\"y0\") !== -1 ? createStringMap(props, \"y\") : undefined\n    };\n  }\n\n  var data = preformattedData ? dataset : dataset.reduce(function (dataArr, datum, index) {\n    // eslint-disable-line complexity\n    datum = parseDatum(datum);\n    var fallbackValues = {\n      x: index,\n      y: datum\n    };\n    var processedValues = expectedKeys.reduce(function (memo, type) {\n      var processedValue = accessor[type](datum);\n      var value = processedValue !== undefined ? processedValue : fallbackValues[type];\n\n      if (value !== undefined) {\n        if (typeof value === \"string\" && stringMap[type]) {\n          memo[\"\".concat(type, \"Name\")] = value;\n          memo[\"_\".concat(type)] = stringMap[type][value];\n        } else {\n          memo[\"_\".concat(type)] = value;\n        }\n      }\n\n      return memo;\n    }, {});\n\n    var formattedDatum = _assign({}, processedValues, datum);\n\n    if (!_isEmpty(formattedDatum)) {\n      dataArr.push(formattedDatum);\n    }\n\n    return dataArr;\n  }, []);\n  var sortedData = sortData(data, props.sortKey, props.sortOrder);\n  var cleanedData = cleanData(sortedData, props);\n  return addEventKeys(props, cleanedData);\n}\n/**\n * Returns generated x and y data based on domain and sample from props\n * @param {Object} props: the props object\n * @returns {Array} an array of data\n */\n\nexport function generateData(props) {\n  var xValues = generateDataArray(props, \"x\");\n  var yValues = generateDataArray(props, \"y\");\n  var values = xValues.map(function (x, i) {\n    return {\n      x: x,\n      y: yValues[i]\n    };\n  });\n  return values;\n}\n/**\n * Returns an array of categories for a given axis\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} an array of categories\n */\n\nexport function getCategories(props, axis) {\n  return props.categories && !Array.isArray(props.categories) ? props.categories[axis] : props.categories;\n}\n/**\n * Returns an array of formatted data\n * @param {Object} props: the props object\n * @returns {Array} an array of data\n */\n\nexport function getData(props) {\n  return props.data ? formatData(props.data, props) : formatData(generateData(props), props);\n}\n/**\n * Returns an array of strings from axis tickValues for a given axis\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} an array of strings\n */\n\nexport function getStringsFromAxes(props, axis) {\n  var tickValues = props.tickValues,\n      tickFormat = props.tickFormat;\n  var tickValueArray;\n\n  if (!tickValues || !Array.isArray(tickValues) && !tickValues[axis]) {\n    tickValueArray = tickFormat && Array.isArray(tickFormat) ? tickFormat : [];\n  } else {\n    tickValueArray = tickValues[axis] || tickValues;\n  }\n\n  return tickValueArray.filter(function (val) {\n    return typeof val === \"string\";\n  });\n}\n/**\n * Returns an array of strings from categories for a given axis\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} an array of strings\n */\n\nexport function getStringsFromCategories(props, axis) {\n  if (!props.categories) {\n    return [];\n  }\n\n  var categories = getCategories(props, axis);\n  var categoryStrings = categories && categories.filter(function (val) {\n    return typeof val === \"string\";\n  });\n  return categoryStrings ? Collection.removeUndefined(categoryStrings) : [];\n}\n/**\n * Returns an array of strings from data\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} an array of strings\n */\n\nexport function getStringsFromData(props, axis) {\n  var isArrayOrIterable = Array.isArray(props.data) || Immutable.isIterable(props.data);\n\n  if (!isArrayOrIterable) {\n    return [];\n  }\n\n  var key = props[axis] === undefined ? axis : props[axis];\n  var accessor = Helpers.createAccessor(key); // support immutable data\n\n  var data = props.data.reduce(function (memo, d) {\n    memo.push(parseDatum(d));\n    return memo;\n  }, []);\n  var sortedData = sortData(data, props.sortKey, props.sortOrder);\n  var dataStrings = sortedData.reduce(function (dataArr, datum) {\n    datum = parseDatum(datum);\n    dataArr.push(accessor(datum));\n    return dataArr;\n  }, []).filter(function (datum) {\n    return typeof datum === \"string\";\n  }); // return a unique set of strings\n\n  return dataStrings.reduce(function (prev, curr) {\n    if (curr !== undefined && curr !== null && prev.indexOf(curr) === -1) {\n      prev.push(curr);\n    }\n\n    return prev;\n  }, []);\n}\n/**\n * Checks whether a given component can be used to calculate data\n * @param {Component} component: a React component instance\n * @returns {Boolean} Returns true if the given component has a role included in the whitelist\n */\n\nexport function isDataComponent(component) {\n  var getRole = function (child) {\n    return child && child.type ? child.type.role : \"\";\n  };\n\n  var role = getRole(component);\n\n  if (role === \"portal\") {\n    var children = React.Children.toArray(component.props.children);\n    role = children.length ? getRole(children[0]) : \"\";\n  }\n\n  var whitelist = [\"area\", \"bar\", \"boxplot\", \"candlestick\", \"errorbar\", \"group\", \"histogram\", \"line\", \"pie\", \"scatter\", \"stack\", \"voronoi\"];\n  return _includes(whitelist, role);\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}