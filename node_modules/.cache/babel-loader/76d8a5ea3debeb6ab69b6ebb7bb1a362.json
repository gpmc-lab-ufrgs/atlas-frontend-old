{"ast":null,"code":"import _keys from \"lodash/keys\";\nimport _identity from \"lodash/identity\";\nimport _defaults from \"lodash/defaults\";\nimport _assign from \"lodash/assign\";\nimport React from \"react\";\n\nfunction getDatumKey(datum, idx) {\n  return (datum.key || idx).toString();\n}\n\nfunction getKeyedData(data) {\n  return data.reduce(function (keyedData, datum, idx) {\n    var key = getDatumKey(datum, idx);\n    keyedData[key] = datum;\n    return keyedData;\n  }, {});\n}\n\nfunction getKeyedDataDifference(a, b) {\n  var hasDifference = false;\n\n  var difference = _keys(a).reduce(function (_difference, key) {\n    if (!(key in b)) {\n      hasDifference = true;\n      _difference[key] = true;\n    }\n\n    return _difference;\n  }, {});\n\n  return hasDifference && difference;\n}\n/**\n * Calculate which data-points exist in oldData and not nextData -\n * these are the `exiting` data-points.  Also calculate which\n * data-points exist in nextData and not oldData - these are the\n * `entering` data-points.\n *\n * @param  {Array} oldData   this.props.data Array\n * @param  {Array} nextData  this.props.data Array\n *\n * @return {Object}          Object with `entering` and `exiting` properties.\n *                           entering[datum.key] will be true if the data is\n *                           entering, and similarly for `exiting`.\n */\n\n\nfunction getNodeTransitions(oldData, nextData) {\n  var oldDataKeyed = oldData && getKeyedData(oldData);\n  var nextDataKeyed = nextData && getKeyedData(nextData);\n  return {\n    entering: oldDataKeyed && getKeyedDataDifference(nextDataKeyed, oldDataKeyed),\n    exiting: nextDataKeyed && getKeyedDataDifference(oldDataKeyed, nextDataKeyed)\n  };\n}\n\nfunction getChildData(child) {\n  if (child.type && child.type.getData) {\n    return child.type.getData(child.props);\n  }\n\n  return child.props && child.props.data || false;\n}\n/**\n * If a parent component has animation enabled, calculate the transitions\n * for any data of any child component that supports data transitions\n * Data transitions are defined as any two datasets where data nodes exist\n * in the first set and not the second, in the second and not the first,\n * or both.\n *\n * @param  {Children}  oldChildren   this.props.children from old props\n * @param  {Children}  nextChildren  this.props.children from next props\n *\n * @return {Object}                  Object with the following properties:\n *                                    - nodesWillExit\n *                                    - nodesWillEnter\n *                                    - childrenTransitions\n *                                    - nodesShouldEnter\n */\n\n\nexport function getInitialTransitionState(oldChildren, nextChildren) {\n  var nodesWillExit = false;\n  var nodesWillEnter = false;\n\n  var getTransition = function (oldChild, newChild) {\n    if (!newChild || oldChild.type !== newChild.type) {\n      return {};\n    }\n\n    var _ref = getNodeTransitions(getChildData(oldChild), getChildData(newChild)) || {},\n        entering = _ref.entering,\n        exiting = _ref.exiting;\n\n    nodesWillExit = nodesWillExit || !!exiting;\n    nodesWillEnter = nodesWillEnter || !!entering;\n    return {\n      entering: entering || false,\n      exiting: exiting || false\n    };\n  };\n\n  var getTransitionsFromChildren = function (old, next) {\n    return old.map(function (child, idx) {\n      if (child && child.props && child.props.children && next[idx]) {\n        return getTransitionsFromChildren(React.Children.toArray(old[idx].props.children), React.Children.toArray(next[idx].props.children));\n      } // get Transition entering and exiting nodes\n\n\n      return getTransition(child, next[idx]);\n    });\n  };\n\n  var childrenTransitions = getTransitionsFromChildren(React.Children.toArray(oldChildren), React.Children.toArray(nextChildren));\n  return {\n    nodesWillExit: nodesWillExit,\n    nodesWillEnter: nodesWillEnter,\n    childrenTransitions: childrenTransitions,\n    // TODO: This may need to be refactored for the following situation.\n    //       The component receives new props, and the data provided\n    //       is a perfect match for the previous data and domain except\n    //       for new nodes. In this case, we wouldn't want a delay before\n    //       the new nodes appear.\n    nodesShouldEnter: false\n  };\n}\n\nfunction getInitialChildProps(animate, data) {\n  var after = animate.onEnter && animate.onEnter.after ? animate.onEnter.after : _identity;\n  return {\n    data: data.map(function (datum, idx) {\n      return _assign({}, datum, after(datum, idx, data));\n    })\n  };\n} // eslint-disable-next-line max-params\n\n\nfunction getChildBeforeLoad(animate, child, data, cb) {\n  animate = _assign({}, animate, {\n    onEnd: cb\n  });\n\n  if (animate && animate.onLoad && !animate.onLoad.duration) {\n    return {\n      animate: animate,\n      data: data\n    };\n  }\n\n  var before = animate.onLoad && animate.onLoad.before ? animate.onLoad.before : _identity; // If nodes need to exit, transform them with the provided onLoad.before function.\n\n  data = data.map(function (datum, idx) {\n    return _assign({}, datum, before(datum, idx, data));\n  });\n  return {\n    animate: animate,\n    data: data,\n    clipWidth: 0\n  };\n} // eslint-disable-next-line max-params\n\n\nfunction getChildOnLoad(animate, data, cb) {\n  animate = _assign({}, animate, {\n    onEnd: cb\n  });\n\n  if (animate && animate.onLoad && !animate.onLoad.duration) {\n    return {\n      animate: animate,\n      data: data\n    };\n  }\n\n  var after = animate.onLoad && animate.onLoad.after ? animate.onLoad.after : _identity; // If nodes need to exit, transform them with the provided onLoad.after function.\n\n  data = data.map(function (datum, idx) {\n    return _assign({}, datum, after(datum, idx, data));\n  });\n  return {\n    animate: animate,\n    data: data\n  };\n} // eslint-disable-next-line max-params, max-len\n\n\nfunction getChildPropsOnExit(animate, child, data, exitingNodes, cb) {\n  // Whether or not _this_ child has exiting nodes, we want the exit-\n  // transition for all children to have the same duration, delay, etc.\n  var onExit = animate && animate.onExit;\n  animate = _assign({}, animate, onExit);\n\n  if (exitingNodes) {\n    // After the exit transition occurs, trigger the animations for\n    // nodes that are neither exiting or entering.\n    animate.onEnd = cb;\n    var before = animate.onExit && animate.onExit.before ? animate.onExit.before : _identity; // If nodes need to exit, transform them with the provided onExit.before function.\n\n    data = data.map(function (datum, idx) {\n      var key = (datum.key || idx).toString();\n      return exitingNodes[key] ? _assign({}, datum, before(datum, idx, data)) : datum;\n    });\n  }\n\n  return {\n    animate: animate,\n    data: data\n  };\n} // eslint-disable-next-line max-params,max-len\n\n\nfunction getChildPropsBeforeEnter(animate, child, data, enteringNodes, cb) {\n  if (enteringNodes) {\n    // Perform a normal animation here, except - when it finishes - trigger\n    // the transition for entering nodes.\n    animate = _assign({}, animate, {\n      onEnd: cb\n    });\n    var before = animate.onEnter && animate.onEnter.before ? animate.onEnter.before : _identity; // We want the entering nodes to be included in the transition target\n    // domain.  However, we may not want these nodes to be displayed initially,\n    // so perform the `onEnter.before` transformation on each node.\n\n    data = data.map(function (datum, idx) {\n      var key = (datum.key || idx).toString();\n      return enteringNodes[key] ? _assign({}, datum, before(datum, idx, data)) : datum;\n    });\n  }\n\n  return {\n    animate: animate,\n    data: data\n  };\n} // eslint-disable-next-line max-params, max-len\n\n\nfunction getChildPropsOnEnter(animate, data, enteringNodes, cb) {\n  // Whether or not _this_ child has entering nodes, we want the entering-\n  // transition for all children to have the same duration, delay, etc.\n  var onEnter = animate && animate.onEnter;\n  animate = _assign({}, animate, onEnter);\n\n  if (enteringNodes) {\n    // Old nodes have been transitioned to their new values, and the\n    // domain should encompass the nodes that will now enter. So perform\n    // the `onEnter.after` transformation on each node.\n    animate.onEnd = cb;\n    var after = animate.onEnter && animate.onEnter.after ? animate.onEnter.after : _identity;\n    data = data.map(function (datum, idx) {\n      var key = getDatumKey(datum, idx);\n      return enteringNodes[key] ? _assign({}, datum, after(datum, idx, data)) : datum;\n    });\n  }\n\n  return {\n    animate: animate,\n    data: data\n  };\n}\n/**\n * getTransitionPropsFactory - putting the Java in JavaScript.  This will return a\n * function that returns prop transformations for a child, given that child's props\n * and its index in the parent's children array.\n *\n * In particular, this will include an `animate` object that is set appropriately\n * so that each child will be synchoronized for each stage of a transition\n * animation.  It will also include a transformed `data` object, where each datum\n * is transformed by `animate.onExit` and `animate.onEnter` `before` and `after`\n * functions.\n *\n * @param  {Object}  props       `this.props` for the parent component.\n * @param  {Object} state        `this.state` for the parent component.\n * @param  {Function} setState    Function that, when called, will `this.setState` on\n *                                 the parent component with the provided object.\n *\n * @return {Function}              Child-prop transformation function.\n */\n\n\nexport function getTransitionPropsFactory(props, state, setState) {\n  var nodesWillExit = state && state.nodesWillExit;\n  var nodesWillEnter = state && state.nodesWillEnter;\n  var nodesShouldEnter = state && state.nodesShouldEnter;\n  var nodesShouldLoad = state && state.nodesShouldLoad;\n  var nodesDoneLoad = state && state.nodesDoneLoad;\n  var childrenTransitions = state && state.childrenTransitions || [];\n  var transitionDurations = {\n    enter: props.animate && props.animate.onEnter && props.animate.onEnter.duration,\n    exit: props.animate && props.animate.onExit && props.animate.onExit.duration,\n    load: props.animate && props.animate.onLoad && props.animate.onLoad.duration,\n    move: props.animate && props.animate.duration\n  };\n\n  var onLoad = function (child, data, animate) {\n    if (nodesShouldLoad) {\n      return getChildOnLoad(animate, data, function () {\n        setState({\n          nodesShouldLoad: false,\n          nodesDoneLoad: true\n        });\n      });\n    }\n\n    return getChildBeforeLoad(animate, child, data, function () {\n      setState({\n        nodesDoneLoad: true\n      });\n    });\n  }; // eslint-disable-next-line max-params\n\n\n  var onExit = function (nodes, child, data, animate) {\n    return getChildPropsOnExit(animate, child, data, nodes, function () {\n      setState({\n        nodesWillExit: false\n      });\n    });\n  }; // eslint-disable-next-line max-params\n\n\n  var onEnter = function (nodes, child, data, animate) {\n    if (nodesShouldEnter) {\n      return getChildPropsOnEnter(animate, data, nodes, function () {\n        setState({\n          nodesWillEnter: false\n        });\n      });\n    }\n\n    return getChildPropsBeforeEnter(animate, child, data, nodes, function () {\n      setState({\n        nodesShouldEnter: true\n      });\n    });\n  };\n\n  var getChildTransitionDuration = function (child, type) {\n    var animate = child.props.animate;\n\n    if (!child.type) {\n      return {};\n    }\n\n    var defaultTransitions = child.props && child.props.polar ? child.type.defaultPolarTransitions || child.type.defaultTransitions : child.type.defaultTransitions;\n\n    if (defaultTransitions) {\n      var animationDuration = animate[type] && animate[type].duration;\n      return animationDuration !== undefined ? animationDuration : defaultTransitions[type] && defaultTransitions[type].duration;\n    } else {\n      return {};\n    }\n  }; // eslint-disable-next-line max-statements, complexity, max-len\n\n\n  return function getTransitionProps(child, index) {\n    var data = getChildData(child) || [];\n\n    var animate = _defaults({}, props.animate, child.props.animate);\n\n    var defaultTransitions = child.props.polar ? child.type.defaultPolarTransitions || child.type.defaultTransitions : child.type.defaultTransitions;\n    animate.onExit = _defaults({}, animate.onExit, defaultTransitions && defaultTransitions.onExit);\n    animate.onEnter = _defaults({}, animate.onEnter, defaultTransitions && defaultTransitions.onEnter);\n    animate.onLoad = _defaults({}, animate.onLoad, defaultTransitions && defaultTransitions.onLoad);\n    var childTransitions = childrenTransitions[index] || childrenTransitions[0];\n\n    if (!nodesDoneLoad) {\n      // should do onLoad animation\n      var load = transitionDurations.load !== undefined ? transitionDurations.load : getChildTransitionDuration(child, \"onLoad\");\n      var animation = {\n        duration: load\n      };\n      return onLoad(child, data, _assign({}, animate, animation));\n    } else if (nodesWillExit) {\n      var exitingNodes = childTransitions && childTransitions.exiting;\n      var exit = transitionDurations.exit !== undefined ? transitionDurations.exit : getChildTransitionDuration(child, \"onExit\"); // if nodesWillExit, but this child has no exiting nodes, set a delay instead of a duration\n\n      var _animation = exitingNodes ? {\n        duration: exit\n      } : {\n        delay: exit\n      };\n\n      return onExit(exitingNodes, child, data, _assign({}, animate, _animation));\n    } else if (nodesWillEnter) {\n      var enteringNodes = childTransitions && childTransitions.entering;\n      var enter = transitionDurations.enter !== undefined ? transitionDurations.enter : getChildTransitionDuration(child, \"onEnter\");\n      var move = transitionDurations.move !== undefined ? transitionDurations.move : child.props.animate && child.props.animate.duration;\n      var _animation2 = {\n        duration: nodesShouldEnter && enteringNodes ? enter : move\n      };\n      return onEnter(enteringNodes, child, data, _assign({}, animate, _animation2));\n    } else if (!state && animate && animate.onExit) {\n      // This is the initial render, and nodes may enter when props change. Because\n      // animation interpolation is determined by old- and next- props, data may need\n      // to be augmented with certain properties.\n      //\n      // For example, it may be desired that exiting nodes go from `opacity: 1` to\n      // `opacity: 0`. Without setting this on a per-datum basis, the interpolation\n      // might go from `opacity: undefined` to `opacity: 0`, which would result in\n      // interpolated `opacity: NaN` values.\n      //\n      return getInitialChildProps(animate, data);\n    }\n\n    return {\n      animate: animate,\n      data: data\n    };\n  };\n}","map":{"version":3,"names":["_keys","_identity","_defaults","_assign","React","getDatumKey","datum","idx","key","toString","getKeyedData","data","reduce","keyedData","getKeyedDataDifference","a","b","hasDifference","difference","_difference","getNodeTransitions","oldData","nextData","oldDataKeyed","nextDataKeyed","entering","exiting","getChildData","child","type","getData","props","getInitialTransitionState","oldChildren","nextChildren","nodesWillExit","nodesWillEnter","getTransition","oldChild","newChild","_ref","getTransitionsFromChildren","old","next","map","children","Children","toArray","childrenTransitions","nodesShouldEnter","getInitialChildProps","animate","after","onEnter","getChildBeforeLoad","cb","onEnd","onLoad","duration","before","clipWidth","getChildOnLoad","getChildPropsOnExit","exitingNodes","onExit","getChildPropsBeforeEnter","enteringNodes","getChildPropsOnEnter","getTransitionPropsFactory","state","setState","nodesShouldLoad","nodesDoneLoad","transitionDurations","enter","exit","load","move","nodes","getChildTransitionDuration","defaultTransitions","polar","defaultPolarTransitions","animationDuration","undefined","getTransitionProps","index","childTransitions","animation","_animation","delay","_animation2"],"sources":["/Users/leonardogomes/Documents/atlas/atlas/node_modules/victory-core/es/victory-util/transitions.js"],"sourcesContent":["import _keys from \"lodash/keys\";\nimport _identity from \"lodash/identity\";\nimport _defaults from \"lodash/defaults\";\nimport _assign from \"lodash/assign\";\nimport React from \"react\";\n\nfunction getDatumKey(datum, idx) {\n  return (datum.key || idx).toString();\n}\n\nfunction getKeyedData(data) {\n  return data.reduce(function (keyedData, datum, idx) {\n    var key = getDatumKey(datum, idx);\n    keyedData[key] = datum;\n    return keyedData;\n  }, {});\n}\n\nfunction getKeyedDataDifference(a, b) {\n  var hasDifference = false;\n\n  var difference = _keys(a).reduce(function (_difference, key) {\n    if (!(key in b)) {\n      hasDifference = true;\n      _difference[key] = true;\n    }\n\n    return _difference;\n  }, {});\n\n  return hasDifference && difference;\n}\n/**\n * Calculate which data-points exist in oldData and not nextData -\n * these are the `exiting` data-points.  Also calculate which\n * data-points exist in nextData and not oldData - these are the\n * `entering` data-points.\n *\n * @param  {Array} oldData   this.props.data Array\n * @param  {Array} nextData  this.props.data Array\n *\n * @return {Object}          Object with `entering` and `exiting` properties.\n *                           entering[datum.key] will be true if the data is\n *                           entering, and similarly for `exiting`.\n */\n\n\nfunction getNodeTransitions(oldData, nextData) {\n  var oldDataKeyed = oldData && getKeyedData(oldData);\n  var nextDataKeyed = nextData && getKeyedData(nextData);\n  return {\n    entering: oldDataKeyed && getKeyedDataDifference(nextDataKeyed, oldDataKeyed),\n    exiting: nextDataKeyed && getKeyedDataDifference(oldDataKeyed, nextDataKeyed)\n  };\n}\n\nfunction getChildData(child) {\n  if (child.type && child.type.getData) {\n    return child.type.getData(child.props);\n  }\n\n  return child.props && child.props.data || false;\n}\n/**\n * If a parent component has animation enabled, calculate the transitions\n * for any data of any child component that supports data transitions\n * Data transitions are defined as any two datasets where data nodes exist\n * in the first set and not the second, in the second and not the first,\n * or both.\n *\n * @param  {Children}  oldChildren   this.props.children from old props\n * @param  {Children}  nextChildren  this.props.children from next props\n *\n * @return {Object}                  Object with the following properties:\n *                                    - nodesWillExit\n *                                    - nodesWillEnter\n *                                    - childrenTransitions\n *                                    - nodesShouldEnter\n */\n\n\nexport function getInitialTransitionState(oldChildren, nextChildren) {\n  var nodesWillExit = false;\n  var nodesWillEnter = false;\n\n  var getTransition = function (oldChild, newChild) {\n    if (!newChild || oldChild.type !== newChild.type) {\n      return {};\n    }\n\n    var _ref = getNodeTransitions(getChildData(oldChild), getChildData(newChild)) || {},\n        entering = _ref.entering,\n        exiting = _ref.exiting;\n\n    nodesWillExit = nodesWillExit || !!exiting;\n    nodesWillEnter = nodesWillEnter || !!entering;\n    return {\n      entering: entering || false,\n      exiting: exiting || false\n    };\n  };\n\n  var getTransitionsFromChildren = function (old, next) {\n    return old.map(function (child, idx) {\n      if (child && child.props && child.props.children && next[idx]) {\n        return getTransitionsFromChildren(React.Children.toArray(old[idx].props.children), React.Children.toArray(next[idx].props.children));\n      } // get Transition entering and exiting nodes\n\n\n      return getTransition(child, next[idx]);\n    });\n  };\n\n  var childrenTransitions = getTransitionsFromChildren(React.Children.toArray(oldChildren), React.Children.toArray(nextChildren));\n  return {\n    nodesWillExit: nodesWillExit,\n    nodesWillEnter: nodesWillEnter,\n    childrenTransitions: childrenTransitions,\n    // TODO: This may need to be refactored for the following situation.\n    //       The component receives new props, and the data provided\n    //       is a perfect match for the previous data and domain except\n    //       for new nodes. In this case, we wouldn't want a delay before\n    //       the new nodes appear.\n    nodesShouldEnter: false\n  };\n}\n\nfunction getInitialChildProps(animate, data) {\n  var after = animate.onEnter && animate.onEnter.after ? animate.onEnter.after : _identity;\n  return {\n    data: data.map(function (datum, idx) {\n      return _assign({}, datum, after(datum, idx, data));\n    })\n  };\n} // eslint-disable-next-line max-params\n\n\nfunction getChildBeforeLoad(animate, child, data, cb) {\n  animate = _assign({}, animate, {\n    onEnd: cb\n  });\n\n  if (animate && animate.onLoad && !animate.onLoad.duration) {\n    return {\n      animate: animate,\n      data: data\n    };\n  }\n\n  var before = animate.onLoad && animate.onLoad.before ? animate.onLoad.before : _identity; // If nodes need to exit, transform them with the provided onLoad.before function.\n\n  data = data.map(function (datum, idx) {\n    return _assign({}, datum, before(datum, idx, data));\n  });\n  return {\n    animate: animate,\n    data: data,\n    clipWidth: 0\n  };\n} // eslint-disable-next-line max-params\n\n\nfunction getChildOnLoad(animate, data, cb) {\n  animate = _assign({}, animate, {\n    onEnd: cb\n  });\n\n  if (animate && animate.onLoad && !animate.onLoad.duration) {\n    return {\n      animate: animate,\n      data: data\n    };\n  }\n\n  var after = animate.onLoad && animate.onLoad.after ? animate.onLoad.after : _identity; // If nodes need to exit, transform them with the provided onLoad.after function.\n\n  data = data.map(function (datum, idx) {\n    return _assign({}, datum, after(datum, idx, data));\n  });\n  return {\n    animate: animate,\n    data: data\n  };\n} // eslint-disable-next-line max-params, max-len\n\n\nfunction getChildPropsOnExit(animate, child, data, exitingNodes, cb) {\n  // Whether or not _this_ child has exiting nodes, we want the exit-\n  // transition for all children to have the same duration, delay, etc.\n  var onExit = animate && animate.onExit;\n  animate = _assign({}, animate, onExit);\n\n  if (exitingNodes) {\n    // After the exit transition occurs, trigger the animations for\n    // nodes that are neither exiting or entering.\n    animate.onEnd = cb;\n    var before = animate.onExit && animate.onExit.before ? animate.onExit.before : _identity; // If nodes need to exit, transform them with the provided onExit.before function.\n\n    data = data.map(function (datum, idx) {\n      var key = (datum.key || idx).toString();\n      return exitingNodes[key] ? _assign({}, datum, before(datum, idx, data)) : datum;\n    });\n  }\n\n  return {\n    animate: animate,\n    data: data\n  };\n} // eslint-disable-next-line max-params,max-len\n\n\nfunction getChildPropsBeforeEnter(animate, child, data, enteringNodes, cb) {\n  if (enteringNodes) {\n    // Perform a normal animation here, except - when it finishes - trigger\n    // the transition for entering nodes.\n    animate = _assign({}, animate, {\n      onEnd: cb\n    });\n    var before = animate.onEnter && animate.onEnter.before ? animate.onEnter.before : _identity; // We want the entering nodes to be included in the transition target\n    // domain.  However, we may not want these nodes to be displayed initially,\n    // so perform the `onEnter.before` transformation on each node.\n\n    data = data.map(function (datum, idx) {\n      var key = (datum.key || idx).toString();\n      return enteringNodes[key] ? _assign({}, datum, before(datum, idx, data)) : datum;\n    });\n  }\n\n  return {\n    animate: animate,\n    data: data\n  };\n} // eslint-disable-next-line max-params, max-len\n\n\nfunction getChildPropsOnEnter(animate, data, enteringNodes, cb) {\n  // Whether or not _this_ child has entering nodes, we want the entering-\n  // transition for all children to have the same duration, delay, etc.\n  var onEnter = animate && animate.onEnter;\n  animate = _assign({}, animate, onEnter);\n\n  if (enteringNodes) {\n    // Old nodes have been transitioned to their new values, and the\n    // domain should encompass the nodes that will now enter. So perform\n    // the `onEnter.after` transformation on each node.\n    animate.onEnd = cb;\n    var after = animate.onEnter && animate.onEnter.after ? animate.onEnter.after : _identity;\n    data = data.map(function (datum, idx) {\n      var key = getDatumKey(datum, idx);\n      return enteringNodes[key] ? _assign({}, datum, after(datum, idx, data)) : datum;\n    });\n  }\n\n  return {\n    animate: animate,\n    data: data\n  };\n}\n/**\n * getTransitionPropsFactory - putting the Java in JavaScript.  This will return a\n * function that returns prop transformations for a child, given that child's props\n * and its index in the parent's children array.\n *\n * In particular, this will include an `animate` object that is set appropriately\n * so that each child will be synchoronized for each stage of a transition\n * animation.  It will also include a transformed `data` object, where each datum\n * is transformed by `animate.onExit` and `animate.onEnter` `before` and `after`\n * functions.\n *\n * @param  {Object}  props       `this.props` for the parent component.\n * @param  {Object} state        `this.state` for the parent component.\n * @param  {Function} setState    Function that, when called, will `this.setState` on\n *                                 the parent component with the provided object.\n *\n * @return {Function}              Child-prop transformation function.\n */\n\n\nexport function getTransitionPropsFactory(props, state, setState) {\n  var nodesWillExit = state && state.nodesWillExit;\n  var nodesWillEnter = state && state.nodesWillEnter;\n  var nodesShouldEnter = state && state.nodesShouldEnter;\n  var nodesShouldLoad = state && state.nodesShouldLoad;\n  var nodesDoneLoad = state && state.nodesDoneLoad;\n  var childrenTransitions = state && state.childrenTransitions || [];\n  var transitionDurations = {\n    enter: props.animate && props.animate.onEnter && props.animate.onEnter.duration,\n    exit: props.animate && props.animate.onExit && props.animate.onExit.duration,\n    load: props.animate && props.animate.onLoad && props.animate.onLoad.duration,\n    move: props.animate && props.animate.duration\n  };\n\n  var onLoad = function (child, data, animate) {\n    if (nodesShouldLoad) {\n      return getChildOnLoad(animate, data, function () {\n        setState({\n          nodesShouldLoad: false,\n          nodesDoneLoad: true\n        });\n      });\n    }\n\n    return getChildBeforeLoad(animate, child, data, function () {\n      setState({\n        nodesDoneLoad: true\n      });\n    });\n  }; // eslint-disable-next-line max-params\n\n\n  var onExit = function (nodes, child, data, animate) {\n    return getChildPropsOnExit(animate, child, data, nodes, function () {\n      setState({\n        nodesWillExit: false\n      });\n    });\n  }; // eslint-disable-next-line max-params\n\n\n  var onEnter = function (nodes, child, data, animate) {\n    if (nodesShouldEnter) {\n      return getChildPropsOnEnter(animate, data, nodes, function () {\n        setState({\n          nodesWillEnter: false\n        });\n      });\n    }\n\n    return getChildPropsBeforeEnter(animate, child, data, nodes, function () {\n      setState({\n        nodesShouldEnter: true\n      });\n    });\n  };\n\n  var getChildTransitionDuration = function (child, type) {\n    var animate = child.props.animate;\n\n    if (!child.type) {\n      return {};\n    }\n\n    var defaultTransitions = child.props && child.props.polar ? child.type.defaultPolarTransitions || child.type.defaultTransitions : child.type.defaultTransitions;\n\n    if (defaultTransitions) {\n      var animationDuration = animate[type] && animate[type].duration;\n      return animationDuration !== undefined ? animationDuration : defaultTransitions[type] && defaultTransitions[type].duration;\n    } else {\n      return {};\n    }\n  }; // eslint-disable-next-line max-statements, complexity, max-len\n\n\n  return function getTransitionProps(child, index) {\n    var data = getChildData(child) || [];\n\n    var animate = _defaults({}, props.animate, child.props.animate);\n\n    var defaultTransitions = child.props.polar ? child.type.defaultPolarTransitions || child.type.defaultTransitions : child.type.defaultTransitions;\n    animate.onExit = _defaults({}, animate.onExit, defaultTransitions && defaultTransitions.onExit);\n    animate.onEnter = _defaults({}, animate.onEnter, defaultTransitions && defaultTransitions.onEnter);\n    animate.onLoad = _defaults({}, animate.onLoad, defaultTransitions && defaultTransitions.onLoad);\n    var childTransitions = childrenTransitions[index] || childrenTransitions[0];\n\n    if (!nodesDoneLoad) {\n      // should do onLoad animation\n      var load = transitionDurations.load !== undefined ? transitionDurations.load : getChildTransitionDuration(child, \"onLoad\");\n      var animation = {\n        duration: load\n      };\n      return onLoad(child, data, _assign({}, animate, animation));\n    } else if (nodesWillExit) {\n      var exitingNodes = childTransitions && childTransitions.exiting;\n      var exit = transitionDurations.exit !== undefined ? transitionDurations.exit : getChildTransitionDuration(child, \"onExit\"); // if nodesWillExit, but this child has no exiting nodes, set a delay instead of a duration\n\n      var _animation = exitingNodes ? {\n        duration: exit\n      } : {\n        delay: exit\n      };\n\n      return onExit(exitingNodes, child, data, _assign({}, animate, _animation));\n    } else if (nodesWillEnter) {\n      var enteringNodes = childTransitions && childTransitions.entering;\n      var enter = transitionDurations.enter !== undefined ? transitionDurations.enter : getChildTransitionDuration(child, \"onEnter\");\n      var move = transitionDurations.move !== undefined ? transitionDurations.move : child.props.animate && child.props.animate.duration;\n      var _animation2 = {\n        duration: nodesShouldEnter && enteringNodes ? enter : move\n      };\n      return onEnter(enteringNodes, child, data, _assign({}, animate, _animation2));\n    } else if (!state && animate && animate.onExit) {\n      // This is the initial render, and nodes may enter when props change. Because\n      // animation interpolation is determined by old- and next- props, data may need\n      // to be augmented with certain properties.\n      //\n      // For example, it may be desired that exiting nodes go from `opacity: 1` to\n      // `opacity: 0`. Without setting this on a per-datum basis, the interpolation\n      // might go from `opacity: undefined` to `opacity: 0`, which would result in\n      // interpolated `opacity: NaN` values.\n      //\n      return getInitialChildProps(animate, data);\n    }\n\n    return {\n      animate: animate,\n      data: data\n    };\n  };\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}