{"ast":null,"code":"import _orderBy from \"lodash/orderBy\";\nimport _isPlainObject from \"lodash/isPlainObject\";\nimport { interpolate } from \"victory-vendor/d3-interpolate\";\nexport var isInterpolatable = function (obj) {\n  // d3 turns null into 0 and undefined into NaN, which we don't want.\n  if (obj !== null) {\n    switch (typeof obj) {\n      case \"undefined\":\n        return false;\n\n      case \"number\":\n        // The standard `isNaN` is fine in this case since we already know the\n        // type is number.\n        return !isNaN(obj) && obj !== Number.POSITIVE_INFINITY && obj !== Number.NEGATIVE_INFINITY;\n\n      case \"string\":\n        // d3 might not *actually* be able to interpolate the string, but it\n        // won't cause any issues to let it try.\n        return true;\n\n      case \"boolean\":\n        // d3 turns Booleans into integers, which we don't want. Sure, we could\n        // interpolate from 0 -> 1, but we'd be sending a non-Boolean to\n        // something expecting a Boolean.\n        return false;\n\n      case \"object\":\n        // Don't try to interpolate class instances (except Date or Array).\n        return obj instanceof Date || Array.isArray(obj) || _isPlainObject(obj);\n\n      case \"function\":\n        // Careful! There may be extra properties on function objects that the\n        // component expects to access - for instance, it may be a `d3.scale()`\n        // function, which has its own methods attached. We don't know if the\n        // component is only going to call the function (in which case it's\n        // safely interpolatable) or if it's going to access special properties\n        // (in which case our function generated from `interpolateFunction` will\n        // most likely cause an error. We could check for enumerable properties\n        // on the function object here to see if it's a \"plain\" function, but\n        // let's just require that components prevent such function props from\n        // being animated in the first place.\n        return true;\n    }\n  }\n\n  return false;\n};\n/**\n * Interpolate immediately to the end value at the given step `when`.\n * Some nicer default behavior might be to jump at the halfway point or return\n * `a` if `t` is 0 (instead of always returning `b`). But d3's default\n * interpolator does not do these things:\n *\n *   d3.interpolate('aaa', 'bbb')(0) === 'bbb'\n *\n * ...and things might get wonky if we don't replicate that behavior.\n *\n * @param {any} a - Start value.\n * @param {any} b - End value.\n * @param {Number} when - Step value (0 to 1) at which to jump to `b`.\n * @returns {Function} An interpolation function.\n */\n\nexport var interpolateImmediate = function (a, b) {\n  var when = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  return function (t) {\n    return t < when ? a : b;\n  };\n};\n/**\n * Interpolate to or from a function. The interpolated value will be a function\n * that calls `a` (if it's a function) and `b` (if it's a function) and calls\n * `d3.interpolate` on the resulting values. Note that our function won't\n * necessarily be called (that's up to the component this eventually gets\n * passed to) - but if it does get called, it will return an appropriately\n * interpolated value.\n *\n * @param {any} a - Start value.\n * @param {any} b - End value.\n * @returns {Function} An interpolation function.\n */\n\nexport var interpolateFunction = function (a, b) {\n  return function (t) {\n    if (t >= 1) {\n      return b;\n    }\n\n    return function () {\n      /* eslint-disable no-invalid-this */\n      var aval = typeof a === \"function\" ? a.apply(this, arguments) : a;\n      var bval = typeof b === \"function\" ? b.apply(this, arguments) : b;\n      return interpolate(aval, bval)(t);\n    };\n  };\n};\n/**\n * Interpolate to or from an object. This method is a modification of the object interpolator in\n * d3-interpolate https://github.com/d3/d3-interpolate/blob/master/src/object.js. This interpolator\n * differs in that it uses our custom interpolators when interpolating the value of each property in\n * an object. This allows the correct interpolation of nested objects, including styles\n *\n * @param {any} a - Start value.\n * @param {any} b - End value.\n * @returns {Function} An interpolation function.\n */\n\nexport var interpolateObject = function (a, b) {\n  var interpolateTypes = function (x, y) {\n    if (x === y || !isInterpolatable(x) || !isInterpolatable(y)) {\n      return interpolateImmediate(x, y);\n    }\n\n    if (typeof x === \"function\" || typeof y === \"function\") {\n      return interpolateFunction(x, y);\n    }\n\n    if (typeof x === \"object\" && _isPlainObject(x) || typeof y === \"object\" && _isPlainObject(y)) {\n      return interpolateObject(x, y);\n    }\n\n    return interpolate(x, y);\n  }; // When the value is an array, attempt to sort by \"key\" so that animating nodes may be identified\n  // based on \"key\" instead of index\n\n\n  var keyData = function (val) {\n    return Array.isArray(val) ? _orderBy(val, \"key\") : val;\n  };\n\n  var i = {};\n  var c = {};\n  var k;\n\n  if (a === null || typeof a !== \"object\") {\n    a = {};\n  }\n\n  if (b === null || typeof b !== \"object\") {\n    b = {};\n  }\n\n  for (k in b) {\n    if (k in a) {\n      i[k] = interpolateTypes(keyData(a[k]), keyData(b[k]));\n    } else {\n      c[k] = b[k];\n    }\n  }\n\n  return function (t) {\n    for (k in i) {\n      c[k] = i[k](t);\n    }\n\n    return c;\n  };\n};\nexport var interpolateString = function (a, b) {\n  var format = function (val) {\n    return typeof val === \"string\" ? val.replace(/,/g, \"\") : val;\n  };\n\n  return interpolate(format(a), format(b));\n};\n/**\n * By default, the list of interpolators used by `d3.interpolate` has a few\n * downsides:\n *\n * - `null` values get turned into 0.\n * - `undefined`, `function`, and some other value types get turned into NaN.\n * - Boolean types get turned into numbers, which probably will be meaningless\n *   to whatever is consuming them.\n * - It tries to interpolate between identical start and end values, doing\n *   unnecessary calculations that sometimes result in floating point rounding\n *   errors.\n *\n * If only the default interpolators are used, `VictoryAnimation` will happily\n * pass down NaN (and other bad) values as props to the wrapped component.\n * The component will then either use the incorrect values or complain that it\n * was passed props of the incorrect type. This custom interpolator is added\n * using the `d3.interpolators` API, and prevents such cases from happening\n * for most values.\n *\n * @param {any} a - Start value.\n * @param {any} b - End value.\n * @returns {Function|undefined} An interpolation function, if necessary.\n */\n\nexport var victoryInterpolator = function (a, b) {\n  // If the values are strictly equal, or either value is not interpolatable,\n  // just use either the start value `a` or end value `b` at every step, as\n  // there is no reasonable in-between value.\n  if (a === b || !isInterpolatable(a) || !isInterpolatable(b)) {\n    return interpolateImmediate(a, b);\n  }\n\n  if (typeof a === \"function\" || typeof b === \"function\") {\n    return interpolateFunction(a, b);\n  }\n\n  if (_isPlainObject(a) || _isPlainObject(b)) {\n    return interpolateObject(a, b);\n  }\n\n  if (typeof a === \"string\" || typeof b === \"string\") {\n    return interpolateString(a, b);\n  }\n\n  return interpolate(a, b);\n};","map":{"version":3,"names":["_orderBy","_isPlainObject","interpolate","isInterpolatable","obj","isNaN","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","Date","Array","isArray","interpolateImmediate","a","b","when","arguments","length","undefined","t","interpolateFunction","aval","apply","bval","interpolateObject","interpolateTypes","x","y","keyData","val","i","c","k","interpolateString","format","replace","victoryInterpolator"],"sources":["/Users/leonardogomes/Documents/atlas/atlas/node_modules/victory-core/es/victory-animation/util.js"],"sourcesContent":["import _orderBy from \"lodash/orderBy\";\nimport _isPlainObject from \"lodash/isPlainObject\";\nimport { interpolate } from \"victory-vendor/d3-interpolate\";\nexport var isInterpolatable = function (obj) {\n  // d3 turns null into 0 and undefined into NaN, which we don't want.\n  if (obj !== null) {\n    switch (typeof obj) {\n      case \"undefined\":\n        return false;\n\n      case \"number\":\n        // The standard `isNaN` is fine in this case since we already know the\n        // type is number.\n        return !isNaN(obj) && obj !== Number.POSITIVE_INFINITY && obj !== Number.NEGATIVE_INFINITY;\n\n      case \"string\":\n        // d3 might not *actually* be able to interpolate the string, but it\n        // won't cause any issues to let it try.\n        return true;\n\n      case \"boolean\":\n        // d3 turns Booleans into integers, which we don't want. Sure, we could\n        // interpolate from 0 -> 1, but we'd be sending a non-Boolean to\n        // something expecting a Boolean.\n        return false;\n\n      case \"object\":\n        // Don't try to interpolate class instances (except Date or Array).\n        return obj instanceof Date || Array.isArray(obj) || _isPlainObject(obj);\n\n      case \"function\":\n        // Careful! There may be extra properties on function objects that the\n        // component expects to access - for instance, it may be a `d3.scale()`\n        // function, which has its own methods attached. We don't know if the\n        // component is only going to call the function (in which case it's\n        // safely interpolatable) or if it's going to access special properties\n        // (in which case our function generated from `interpolateFunction` will\n        // most likely cause an error. We could check for enumerable properties\n        // on the function object here to see if it's a \"plain\" function, but\n        // let's just require that components prevent such function props from\n        // being animated in the first place.\n        return true;\n    }\n  }\n\n  return false;\n};\n/**\n * Interpolate immediately to the end value at the given step `when`.\n * Some nicer default behavior might be to jump at the halfway point or return\n * `a` if `t` is 0 (instead of always returning `b`). But d3's default\n * interpolator does not do these things:\n *\n *   d3.interpolate('aaa', 'bbb')(0) === 'bbb'\n *\n * ...and things might get wonky if we don't replicate that behavior.\n *\n * @param {any} a - Start value.\n * @param {any} b - End value.\n * @param {Number} when - Step value (0 to 1) at which to jump to `b`.\n * @returns {Function} An interpolation function.\n */\n\nexport var interpolateImmediate = function (a, b) {\n  var when = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  return function (t) {\n    return t < when ? a : b;\n  };\n};\n/**\n * Interpolate to or from a function. The interpolated value will be a function\n * that calls `a` (if it's a function) and `b` (if it's a function) and calls\n * `d3.interpolate` on the resulting values. Note that our function won't\n * necessarily be called (that's up to the component this eventually gets\n * passed to) - but if it does get called, it will return an appropriately\n * interpolated value.\n *\n * @param {any} a - Start value.\n * @param {any} b - End value.\n * @returns {Function} An interpolation function.\n */\n\nexport var interpolateFunction = function (a, b) {\n  return function (t) {\n    if (t >= 1) {\n      return b;\n    }\n\n    return function () {\n      /* eslint-disable no-invalid-this */\n      var aval = typeof a === \"function\" ? a.apply(this, arguments) : a;\n      var bval = typeof b === \"function\" ? b.apply(this, arguments) : b;\n      return interpolate(aval, bval)(t);\n    };\n  };\n};\n/**\n * Interpolate to or from an object. This method is a modification of the object interpolator in\n * d3-interpolate https://github.com/d3/d3-interpolate/blob/master/src/object.js. This interpolator\n * differs in that it uses our custom interpolators when interpolating the value of each property in\n * an object. This allows the correct interpolation of nested objects, including styles\n *\n * @param {any} a - Start value.\n * @param {any} b - End value.\n * @returns {Function} An interpolation function.\n */\n\nexport var interpolateObject = function (a, b) {\n  var interpolateTypes = function (x, y) {\n    if (x === y || !isInterpolatable(x) || !isInterpolatable(y)) {\n      return interpolateImmediate(x, y);\n    }\n\n    if (typeof x === \"function\" || typeof y === \"function\") {\n      return interpolateFunction(x, y);\n    }\n\n    if (typeof x === \"object\" && _isPlainObject(x) || typeof y === \"object\" && _isPlainObject(y)) {\n      return interpolateObject(x, y);\n    }\n\n    return interpolate(x, y);\n  }; // When the value is an array, attempt to sort by \"key\" so that animating nodes may be identified\n  // based on \"key\" instead of index\n\n\n  var keyData = function (val) {\n    return Array.isArray(val) ? _orderBy(val, \"key\") : val;\n  };\n\n  var i = {};\n  var c = {};\n  var k;\n\n  if (a === null || typeof a !== \"object\") {\n    a = {};\n  }\n\n  if (b === null || typeof b !== \"object\") {\n    b = {};\n  }\n\n  for (k in b) {\n    if (k in a) {\n      i[k] = interpolateTypes(keyData(a[k]), keyData(b[k]));\n    } else {\n      c[k] = b[k];\n    }\n  }\n\n  return function (t) {\n    for (k in i) {\n      c[k] = i[k](t);\n    }\n\n    return c;\n  };\n};\nexport var interpolateString = function (a, b) {\n  var format = function (val) {\n    return typeof val === \"string\" ? val.replace(/,/g, \"\") : val;\n  };\n\n  return interpolate(format(a), format(b));\n};\n/**\n * By default, the list of interpolators used by `d3.interpolate` has a few\n * downsides:\n *\n * - `null` values get turned into 0.\n * - `undefined`, `function`, and some other value types get turned into NaN.\n * - Boolean types get turned into numbers, which probably will be meaningless\n *   to whatever is consuming them.\n * - It tries to interpolate between identical start and end values, doing\n *   unnecessary calculations that sometimes result in floating point rounding\n *   errors.\n *\n * If only the default interpolators are used, `VictoryAnimation` will happily\n * pass down NaN (and other bad) values as props to the wrapped component.\n * The component will then either use the incorrect values or complain that it\n * was passed props of the incorrect type. This custom interpolator is added\n * using the `d3.interpolators` API, and prevents such cases from happening\n * for most values.\n *\n * @param {any} a - Start value.\n * @param {any} b - End value.\n * @returns {Function|undefined} An interpolation function, if necessary.\n */\n\nexport var victoryInterpolator = function (a, b) {\n  // If the values are strictly equal, or either value is not interpolatable,\n  // just use either the start value `a` or end value `b` at every step, as\n  // there is no reasonable in-between value.\n  if (a === b || !isInterpolatable(a) || !isInterpolatable(b)) {\n    return interpolateImmediate(a, b);\n  }\n\n  if (typeof a === \"function\" || typeof b === \"function\") {\n    return interpolateFunction(a, b);\n  }\n\n  if (_isPlainObject(a) || _isPlainObject(b)) {\n    return interpolateObject(a, b);\n  }\n\n  if (typeof a === \"string\" || typeof b === \"string\") {\n    return interpolateString(a, b);\n  }\n\n  return interpolate(a, b);\n};"],"mappings":"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"},"metadata":{},"sourceType":"module"}