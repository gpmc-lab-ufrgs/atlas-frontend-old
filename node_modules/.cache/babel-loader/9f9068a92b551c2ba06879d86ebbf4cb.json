{"ast":null,"code":"import _isDate from \"lodash/isDate\";\nimport _includes from \"lodash/includes\";\nimport _isFunction from \"lodash/isFunction\";\nimport _sortedUniq from \"lodash/sortedUniq\";\nimport _isPlainObject from \"lodash/isPlainObject\";\nimport _flatten from \"lodash/flatten\";\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n/* eslint-disable func-style */\n\n/* eslint-disable no-use-before-define */\n\n\nimport React from \"react\";\nimport * as Data from \"./data\";\nimport * as Scale from \"./scale\";\nimport * as Helpers from \"./helpers\";\nimport * as Collection from \"./collection\"; // Private Methods\n\nfunction cleanDomain(domain, props, axis) {\n  var scaleType = Scale.getScaleType(props, axis);\n\n  if (scaleType !== \"log\") {\n    return domain;\n  }\n\n  var rules = function (dom) {\n    var almostZero = dom[0] < 0 || dom[1] < 0 ? -1 / Number.MAX_SAFE_INTEGER : 1 / Number.MAX_SAFE_INTEGER;\n    var domainOne = dom[0] === 0 ? almostZero : dom[0];\n    var domainTwo = dom[1] === 0 ? almostZero : dom[1];\n    return [domainOne, domainTwo];\n  };\n\n  return rules(domain);\n}\n\nfunction getDomainPadding(props, axis) {\n  var formatPadding = function (padding) {\n    return Array.isArray(padding) ? {\n      left: padding[0],\n      right: padding[1]\n    } : {\n      left: padding,\n      right: padding\n    };\n  };\n\n  return _isPlainObject(props.domainPadding) ? formatPadding(props.domainPadding[axis]) : formatPadding(props.domainPadding);\n}\n\nfunction getFlatData(dataset, axis) {\n  return _flatten(dataset).map(function (datum) {\n    return datum[\"_\".concat(axis)] && datum[\"_\".concat(axis)][1] !== undefined ? datum[\"_\".concat(axis)][1] : datum[\"_\".concat(axis)];\n  });\n}\n\nfunction getExtremeFromData(dataset, axis) {\n  var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"min\";\n\n  var getExtreme = function (arr) {\n    return type === \"max\" ? Math.max.apply(Math, _toConsumableArray(arr)) : Math.min.apply(Math, _toConsumableArray(arr));\n  };\n\n  var initialValue = type === \"max\" ? -Infinity : Infinity;\n  var containsDate = false;\n\n  var result = _flatten(dataset).reduce(function (memo, datum) {\n    var current0 = datum[\"_\".concat(axis, \"0\")] !== undefined ? datum[\"_\".concat(axis, \"0\")] : datum[\"_\".concat(axis)];\n    var current1 = datum[\"_\".concat(axis, \"1\")] !== undefined ? datum[\"_\".concat(axis, \"1\")] : datum[\"_\".concat(axis)];\n    var current = getExtreme([current0, current1]);\n    containsDate = containsDate || current0 instanceof Date || current1 instanceof Date;\n    return getExtreme([memo, current]);\n  }, initialValue);\n\n  return containsDate ? new Date(result) : result;\n} //eslint-disable-next-line max-statements\n\n\nfunction padDomain(domain, props, axis) {\n  if (!props.domainPadding) {\n    return domain;\n  }\n\n  var minDomain = getMinFromProps(props, axis);\n  var maxDomain = getMaxFromProps(props, axis);\n  var padding = getDomainPadding(props, axis);\n\n  if (!padding.left && !padding.right) {\n    return domain;\n  }\n\n  var min = Collection.getMinValue(domain);\n  var max = Collection.getMaxValue(domain);\n  var currentAxis = Helpers.getCurrentAxis(axis, props.horizontal);\n  var range = Helpers.getRange(props, currentAxis);\n  var rangeExtent = Math.abs(range[0] - range[1]);\n  var paddedRangeExtent = Math.max(rangeExtent - padding.left - padding.right, 1);\n  var paddedDomainExtent = Math.abs(max.valueOf() - min.valueOf()) / paddedRangeExtent * rangeExtent;\n  var simplePadding = {\n    left: paddedDomainExtent * padding.left / rangeExtent,\n    right: paddedDomainExtent * padding.right / rangeExtent\n  };\n  var paddedDomain = {\n    min: min.valueOf() - simplePadding.left,\n    max: max.valueOf() + simplePadding.right\n  };\n  var singleQuadrantDomainPadding = _isPlainObject(props.singleQuadrantDomainPadding) ? props.singleQuadrantDomainPadding[axis] : props.singleQuadrantDomainPadding;\n  var addsQuadrants = min >= 0 && paddedDomain.min <= 0 || max <= 0 && paddedDomain.max >= 0;\n\n  var adjust = function (val, type) {\n    var coerce = type === \"min\" && min >= 0 && val <= 0 || type === \"max\" && max <= 0 && val >= 0;\n    return coerce ? 0 : val;\n  };\n\n  if (addsQuadrants && singleQuadrantDomainPadding !== false) {\n    // Naive initial padding calculation\n    var initialPadding = {\n      left: Math.abs(max - min) * padding.left / rangeExtent,\n      right: Math.abs(max - min) * padding.right / rangeExtent\n    }; // Adjust the domain by the initial padding\n\n    var adjustedDomain = {\n      min: adjust(min.valueOf() - initialPadding.left, \"min\"),\n      max: adjust(max.valueOf() + initialPadding.right, \"max\")\n    }; // re-calculate padding, taking the adjusted domain into account\n\n    var finalPadding = {\n      left: Math.abs(adjustedDomain.max - adjustedDomain.min) * padding.left / rangeExtent,\n      right: Math.abs(adjustedDomain.max - adjustedDomain.min) * padding.right / rangeExtent\n    }; // Adjust the domain by the final padding\n\n    paddedDomain = {\n      min: adjust(min.valueOf() - finalPadding.left, \"min\"),\n      max: adjust(max.valueOf() + finalPadding.right, \"max\")\n    };\n  } // default to minDomain / maxDomain if they exist\n\n\n  var finalDomain = {\n    min: minDomain !== undefined ? minDomain : paddedDomain.min,\n    max: maxDomain !== undefined ? maxDomain : paddedDomain.max\n  };\n  return min instanceof Date || max instanceof Date ? getDomainFromMinMax(new Date(finalDomain.min), new Date(finalDomain.max)) : getDomainFromMinMax(finalDomain.min, finalDomain.max);\n} // Public Methods\n\n/**\n * Returns a getDomain function\n * @param {Function} getDomainFromDataFunction: a function that takes props and axis and\n * returns a domain based on data\n * @param {Function} formatDomainFunction: a function that takes domain, props, and axis and\n * returns a formatted domain\n * @returns {Function} a function that takes props and axis and returns a formatted domain\n */\n\n\nexport function createDomainFunction(getDomainFromDataFunction, formatDomainFunction) {\n  getDomainFromDataFunction = _isFunction(getDomainFromDataFunction) ? getDomainFromDataFunction : getDomainFromData;\n  formatDomainFunction = _isFunction(formatDomainFunction) ? formatDomainFunction : formatDomain;\n  return function (props, axis) {\n    var propsDomain = getDomainFromProps(props, axis);\n\n    if (propsDomain) {\n      return formatDomainFunction(propsDomain, props, axis);\n    }\n\n    var categories = Data.getCategories(props, axis);\n    var domain = categories ? getDomainFromCategories(props, axis, categories) : getDomainFromDataFunction(props, axis);\n    return domain ? formatDomainFunction(domain, props, axis) : undefined;\n  };\n}\n/**\n * Returns a formatted domain.\n * @param {Array} domain: a domain in the form of a two element array\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} a domain in the form of a two element array\n */\n\nexport function formatDomain(domain, props, axis) {\n  return cleanDomain(padDomain(domain, props, axis), props, axis);\n}\n/**\n * Returns a domain for a given axis based on props, category, or data\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} the domain for the given axis\n */\n\nexport function getDomain(props, axis) {\n  return createDomainFunction()(props, axis);\n}\n/**\n * Returns a domain based on categories if they exist\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @param {Array} categories: an array of categories corresponding to a given axis\n * @returns {Array|undefined} returns a domain from categories or undefined\n */\n\nexport function getDomainFromCategories(props, axis, categories) {\n  categories = categories || Data.getCategories(props, axis);\n  var polar = props.polar,\n      _props$startAngle = props.startAngle,\n      startAngle = _props$startAngle === void 0 ? 0 : _props$startAngle,\n      _props$endAngle = props.endAngle,\n      endAngle = _props$endAngle === void 0 ? 360 : _props$endAngle;\n\n  if (!categories) {\n    return undefined;\n  }\n\n  var minDomain = getMinFromProps(props, axis);\n  var maxDomain = getMaxFromProps(props, axis);\n  var stringArray = Collection.containsStrings(categories) ? Data.getStringsFromCategories(props, axis) : [];\n  var stringMap = stringArray.length === 0 ? null : stringArray.reduce(function (memo, string, index) {\n    memo[string] = index + 1;\n    return memo;\n  }, {});\n  var categoryValues = stringMap ? categories.map(function (value) {\n    return stringMap[value];\n  }) : categories;\n  var min = minDomain !== undefined ? minDomain : Collection.getMinValue(categoryValues);\n  var max = maxDomain !== undefined ? maxDomain : Collection.getMaxValue(categoryValues);\n  var categoryDomain = getDomainFromMinMax(min, max);\n  return polar && axis === \"x\" && Math.abs(startAngle - endAngle) === 360 ? getSymmetricDomain(categoryDomain, categoryValues) : categoryDomain;\n}\n/**\n * Returns a domain from a dataset for a given axis\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @param {Array} dataset: an array of data\n * @returns {Array} the domain based on data\n */\n\nexport function getDomainFromData(props, axis, dataset) {\n  dataset = dataset || Data.getData(props);\n  var polar = props.polar,\n      _props$startAngle2 = props.startAngle,\n      startAngle = _props$startAngle2 === void 0 ? 0 : _props$startAngle2,\n      _props$endAngle2 = props.endAngle,\n      endAngle = _props$endAngle2 === void 0 ? 360 : _props$endAngle2;\n  var minDomain = getMinFromProps(props, axis);\n  var maxDomain = getMaxFromProps(props, axis);\n\n  if (dataset.length < 1) {\n    return minDomain !== undefined && maxDomain !== undefined ? getDomainFromMinMax(minDomain, maxDomain) : undefined;\n  }\n\n  var min = minDomain !== undefined ? minDomain : getExtremeFromData(dataset, axis, \"min\");\n  var max = maxDomain !== undefined ? maxDomain : getExtremeFromData(dataset, axis, \"max\");\n  var domain = getDomainFromMinMax(min, max);\n  return polar && axis === \"x\" && Math.abs(startAngle - endAngle) === 360 ? getSymmetricDomain(domain, getFlatData(dataset, axis)) : domain;\n}\n/**\n * Returns a domain in the form of a two element array given a min and max value.\n * @param {Number|Date} min: the props object\n * @param {Number|Date} max: the current axis\n * @returns {Array} the minDomain based on props\n */\n\nexport function getDomainFromMinMax(min, max) {\n  var getSinglePointDomain = function (val) {\n    // d3-scale does not properly resolve very small differences.\n    var verySmallNumber = // eslint-disable-next-line no-magic-numbers\n    val === 0 ? 2 * Math.pow(10, -10) : Math.pow(10, -10);\n    var verySmallDate = 1;\n    var minVal = val instanceof Date ? new Date(+val - verySmallDate) : +val - verySmallNumber;\n    var maxVal = val instanceof Date ? new Date(+val + verySmallDate) : +val + verySmallNumber;\n    return val === 0 ? [0, maxVal] : [minVal, maxVal];\n  };\n\n  return +min === +max ? getSinglePointDomain(max) : [min, max];\n}\n/**\n * Returns a the domain for a given axis if domain is given in props\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array|undefined} the domain based on props\n */\n\nexport function getDomainFromProps(props, axis) {\n  var minDomain = getMinFromProps(props, axis);\n  var maxDomain = getMaxFromProps(props, axis);\n\n  if (_isPlainObject(props.domain) && props.domain[axis]) {\n    return props.domain[axis];\n  } else if (Array.isArray(props.domain)) {\n    return props.domain;\n  } else if (minDomain !== undefined && maxDomain !== undefined) {\n    return getDomainFromMinMax(minDomain, maxDomain);\n  }\n\n  return undefined;\n}\n/**\n * Returns a domain for a given axis. This method forces the domain to include\n * zero unless the domain is explicitly specified in props.\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} the domain for the given axis\n */\n\nexport function getDomainWithZero(props, axis) {\n  var propsDomain = getDomainFromProps(props, axis);\n\n  if (propsDomain) {\n    return propsDomain;\n  }\n\n  var dataset = Data.getData(props);\n  var y0Min = dataset.reduce(function (min, datum) {\n    return datum._y0 < min ? datum._y0 : min;\n  }, Infinity);\n\n  var ensureZero = function (domain) {\n    if (axis === \"x\") {\n      return domain;\n    }\n\n    var defaultMin = y0Min !== Infinity ? y0Min : 0;\n    var maxDomainProp = getMaxFromProps(props, axis);\n    var minDomainProp = getMinFromProps(props, axis);\n    var max = maxDomainProp !== undefined ? maxDomainProp : Collection.getMaxValue(domain, defaultMin);\n    var min = minDomainProp !== undefined ? minDomainProp : Collection.getMinValue(domain, defaultMin);\n    return getDomainFromMinMax(min, max);\n  };\n\n  var getDomainFunction = function () {\n    return getDomainFromData(props, axis, dataset);\n  };\n\n  var formatDomainFunction = function (domain) {\n    return formatDomain(ensureZero(domain), props, axis);\n  };\n\n  return createDomainFunction(getDomainFunction, formatDomainFunction)(props, axis);\n}\n/**\n * Returns the maxDomain from props if it exists\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Number|Date|undefined} the maxDomain based on props\n */\n\nexport function getMaxFromProps(props, axis) {\n  if (_isPlainObject(props.maxDomain) && props.maxDomain[axis] !== undefined) {\n    return props.maxDomain[axis];\n  }\n\n  return typeof props.maxDomain === \"number\" || _isDate(props.maxDomain) ? props.maxDomain : undefined;\n}\n/**\n * Returns the minDomain from props if it exists\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Number|Date|undefined} the minDomain based on props\n */\n\nexport function getMinFromProps(props, axis) {\n  if (_isPlainObject(props.minDomain) && props.minDomain[axis] !== undefined) {\n    return props.minDomain[axis];\n  }\n\n  return typeof props.minDomain === \"number\" || _isDate(props.minDomain) ? props.minDomain : undefined;\n}\n/**\n * Returns a symmetrically padded domain for polar charts\n * @param {Array} domain: the original domain\n * @param {Array} values: a flat array of values corresponding to either tickValues, or data values\n * for a given dimension i.e. only x values.\n * @returns {Array} the symmetric domain\n */\n\nexport function getSymmetricDomain(domain, values) {\n  var processedData = _sortedUniq(values.sort(function (a, b) {\n    return a - b;\n  }));\n\n  var step = processedData[1] - processedData[0];\n  return [domain[0], domain[1] + step];\n}\n/**\n * Checks whether a given component can be used to calculate domain\n * @param {Component} component: a React component instance\n * @returns {Boolean} Returns true if the given component has a role included in the whitelist\n */\n\nexport function isDomainComponent(component) {\n  var getRole = function (child) {\n    return child && child.type ? child.type.role : \"\";\n  };\n\n  var role = getRole(component);\n\n  if (role === \"portal\") {\n    var children = React.Children.toArray(component.props.children);\n    role = children.length ? getRole(children[0]) : \"\";\n  }\n\n  var whitelist = [\"area\", \"axis\", \"bar\", \"boxplot\", \"candlestick\", \"errorbar\", \"group\", \"histogram\", \"line\", \"pie\", \"scatter\", \"stack\", \"voronoi\"];\n  return _includes(whitelist, role);\n}","map":{"version":3,"names":["_isDate","_includes","_isFunction","_sortedUniq","_isPlainObject","_flatten","_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_unsupportedIterableToArray","_nonIterableSpread","TypeError","o","minLen","_arrayLikeToArray","n","Object","prototype","toString","call","slice","constructor","name","Array","from","test","iter","Symbol","iterator","isArray","len","length","i","arr2","React","Data","Scale","Helpers","Collection","cleanDomain","domain","props","axis","scaleType","getScaleType","rules","dom","almostZero","Number","MAX_SAFE_INTEGER","domainOne","domainTwo","getDomainPadding","formatPadding","padding","left","right","domainPadding","getFlatData","dataset","map","datum","concat","undefined","getExtremeFromData","type","arguments","getExtreme","Math","max","apply","min","initialValue","Infinity","containsDate","result","reduce","memo","current0","current1","current","Date","padDomain","minDomain","getMinFromProps","maxDomain","getMaxFromProps","getMinValue","getMaxValue","currentAxis","getCurrentAxis","horizontal","range","getRange","rangeExtent","abs","paddedRangeExtent","paddedDomainExtent","valueOf","simplePadding","paddedDomain","singleQuadrantDomainPadding","addsQuadrants","adjust","val","coerce","initialPadding","adjustedDomain","finalPadding","finalDomain","getDomainFromMinMax","createDomainFunction","getDomainFromDataFunction","formatDomainFunction","getDomainFromData","formatDomain","propsDomain","getDomainFromProps","categories","getCategories","getDomainFromCategories","getDomain","polar","_props$startAngle","startAngle","_props$endAngle","endAngle","stringArray","containsStrings","getStringsFromCategories","stringMap","string","index","categoryValues","value","categoryDomain","getSymmetricDomain","getData","_props$startAngle2","_props$endAngle2","getSinglePointDomain","verySmallNumber","pow","verySmallDate","minVal","maxVal","getDomainWithZero","y0Min","_y0","ensureZero","defaultMin","maxDomainProp","minDomainProp","getDomainFunction","values","processedData","sort","a","b","step","isDomainComponent","component","getRole","child","role","children","Children","toArray","whitelist"],"sources":["/Users/leonardogomes/Documents/atlas/atlas/node_modules/victory-core/es/victory-util/domain.js"],"sourcesContent":["import _isDate from \"lodash/isDate\";\nimport _includes from \"lodash/includes\";\nimport _isFunction from \"lodash/isFunction\";\nimport _sortedUniq from \"lodash/sortedUniq\";\nimport _isPlainObject from \"lodash/isPlainObject\";\nimport _flatten from \"lodash/flatten\";\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/* eslint-disable func-style */\n\n/* eslint-disable no-use-before-define */\nimport React from \"react\";\nimport * as Data from \"./data\";\nimport * as Scale from \"./scale\";\nimport * as Helpers from \"./helpers\";\nimport * as Collection from \"./collection\"; // Private Methods\n\nfunction cleanDomain(domain, props, axis) {\n  var scaleType = Scale.getScaleType(props, axis);\n\n  if (scaleType !== \"log\") {\n    return domain;\n  }\n\n  var rules = function (dom) {\n    var almostZero = dom[0] < 0 || dom[1] < 0 ? -1 / Number.MAX_SAFE_INTEGER : 1 / Number.MAX_SAFE_INTEGER;\n    var domainOne = dom[0] === 0 ? almostZero : dom[0];\n    var domainTwo = dom[1] === 0 ? almostZero : dom[1];\n    return [domainOne, domainTwo];\n  };\n\n  return rules(domain);\n}\n\nfunction getDomainPadding(props, axis) {\n  var formatPadding = function (padding) {\n    return Array.isArray(padding) ? {\n      left: padding[0],\n      right: padding[1]\n    } : {\n      left: padding,\n      right: padding\n    };\n  };\n\n  return _isPlainObject(props.domainPadding) ? formatPadding(props.domainPadding[axis]) : formatPadding(props.domainPadding);\n}\n\nfunction getFlatData(dataset, axis) {\n  return _flatten(dataset).map(function (datum) {\n    return datum[\"_\".concat(axis)] && datum[\"_\".concat(axis)][1] !== undefined ? datum[\"_\".concat(axis)][1] : datum[\"_\".concat(axis)];\n  });\n}\n\nfunction getExtremeFromData(dataset, axis) {\n  var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"min\";\n\n  var getExtreme = function (arr) {\n    return type === \"max\" ? Math.max.apply(Math, _toConsumableArray(arr)) : Math.min.apply(Math, _toConsumableArray(arr));\n  };\n\n  var initialValue = type === \"max\" ? -Infinity : Infinity;\n  var containsDate = false;\n\n  var result = _flatten(dataset).reduce(function (memo, datum) {\n    var current0 = datum[\"_\".concat(axis, \"0\")] !== undefined ? datum[\"_\".concat(axis, \"0\")] : datum[\"_\".concat(axis)];\n    var current1 = datum[\"_\".concat(axis, \"1\")] !== undefined ? datum[\"_\".concat(axis, \"1\")] : datum[\"_\".concat(axis)];\n    var current = getExtreme([current0, current1]);\n    containsDate = containsDate || current0 instanceof Date || current1 instanceof Date;\n    return getExtreme([memo, current]);\n  }, initialValue);\n\n  return containsDate ? new Date(result) : result;\n} //eslint-disable-next-line max-statements\n\n\nfunction padDomain(domain, props, axis) {\n  if (!props.domainPadding) {\n    return domain;\n  }\n\n  var minDomain = getMinFromProps(props, axis);\n  var maxDomain = getMaxFromProps(props, axis);\n  var padding = getDomainPadding(props, axis);\n\n  if (!padding.left && !padding.right) {\n    return domain;\n  }\n\n  var min = Collection.getMinValue(domain);\n  var max = Collection.getMaxValue(domain);\n  var currentAxis = Helpers.getCurrentAxis(axis, props.horizontal);\n  var range = Helpers.getRange(props, currentAxis);\n  var rangeExtent = Math.abs(range[0] - range[1]);\n  var paddedRangeExtent = Math.max(rangeExtent - padding.left - padding.right, 1);\n  var paddedDomainExtent = Math.abs(max.valueOf() - min.valueOf()) / paddedRangeExtent * rangeExtent;\n  var simplePadding = {\n    left: paddedDomainExtent * padding.left / rangeExtent,\n    right: paddedDomainExtent * padding.right / rangeExtent\n  };\n  var paddedDomain = {\n    min: min.valueOf() - simplePadding.left,\n    max: max.valueOf() + simplePadding.right\n  };\n  var singleQuadrantDomainPadding = _isPlainObject(props.singleQuadrantDomainPadding) ? props.singleQuadrantDomainPadding[axis] : props.singleQuadrantDomainPadding;\n  var addsQuadrants = min >= 0 && paddedDomain.min <= 0 || max <= 0 && paddedDomain.max >= 0;\n\n  var adjust = function (val, type) {\n    var coerce = type === \"min\" && min >= 0 && val <= 0 || type === \"max\" && max <= 0 && val >= 0;\n    return coerce ? 0 : val;\n  };\n\n  if (addsQuadrants && singleQuadrantDomainPadding !== false) {\n    // Naive initial padding calculation\n    var initialPadding = {\n      left: Math.abs(max - min) * padding.left / rangeExtent,\n      right: Math.abs(max - min) * padding.right / rangeExtent\n    }; // Adjust the domain by the initial padding\n\n    var adjustedDomain = {\n      min: adjust(min.valueOf() - initialPadding.left, \"min\"),\n      max: adjust(max.valueOf() + initialPadding.right, \"max\")\n    }; // re-calculate padding, taking the adjusted domain into account\n\n    var finalPadding = {\n      left: Math.abs(adjustedDomain.max - adjustedDomain.min) * padding.left / rangeExtent,\n      right: Math.abs(adjustedDomain.max - adjustedDomain.min) * padding.right / rangeExtent\n    }; // Adjust the domain by the final padding\n\n    paddedDomain = {\n      min: adjust(min.valueOf() - finalPadding.left, \"min\"),\n      max: adjust(max.valueOf() + finalPadding.right, \"max\")\n    };\n  } // default to minDomain / maxDomain if they exist\n\n\n  var finalDomain = {\n    min: minDomain !== undefined ? minDomain : paddedDomain.min,\n    max: maxDomain !== undefined ? maxDomain : paddedDomain.max\n  };\n  return min instanceof Date || max instanceof Date ? getDomainFromMinMax(new Date(finalDomain.min), new Date(finalDomain.max)) : getDomainFromMinMax(finalDomain.min, finalDomain.max);\n} // Public Methods\n\n/**\n * Returns a getDomain function\n * @param {Function} getDomainFromDataFunction: a function that takes props and axis and\n * returns a domain based on data\n * @param {Function} formatDomainFunction: a function that takes domain, props, and axis and\n * returns a formatted domain\n * @returns {Function} a function that takes props and axis and returns a formatted domain\n */\n\n\nexport function createDomainFunction(getDomainFromDataFunction, formatDomainFunction) {\n  getDomainFromDataFunction = _isFunction(getDomainFromDataFunction) ? getDomainFromDataFunction : getDomainFromData;\n  formatDomainFunction = _isFunction(formatDomainFunction) ? formatDomainFunction : formatDomain;\n  return function (props, axis) {\n    var propsDomain = getDomainFromProps(props, axis);\n\n    if (propsDomain) {\n      return formatDomainFunction(propsDomain, props, axis);\n    }\n\n    var categories = Data.getCategories(props, axis);\n    var domain = categories ? getDomainFromCategories(props, axis, categories) : getDomainFromDataFunction(props, axis);\n    return domain ? formatDomainFunction(domain, props, axis) : undefined;\n  };\n}\n/**\n * Returns a formatted domain.\n * @param {Array} domain: a domain in the form of a two element array\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} a domain in the form of a two element array\n */\n\nexport function formatDomain(domain, props, axis) {\n  return cleanDomain(padDomain(domain, props, axis), props, axis);\n}\n/**\n * Returns a domain for a given axis based on props, category, or data\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} the domain for the given axis\n */\n\nexport function getDomain(props, axis) {\n  return createDomainFunction()(props, axis);\n}\n/**\n * Returns a domain based on categories if they exist\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @param {Array} categories: an array of categories corresponding to a given axis\n * @returns {Array|undefined} returns a domain from categories or undefined\n */\n\nexport function getDomainFromCategories(props, axis, categories) {\n  categories = categories || Data.getCategories(props, axis);\n  var polar = props.polar,\n      _props$startAngle = props.startAngle,\n      startAngle = _props$startAngle === void 0 ? 0 : _props$startAngle,\n      _props$endAngle = props.endAngle,\n      endAngle = _props$endAngle === void 0 ? 360 : _props$endAngle;\n\n  if (!categories) {\n    return undefined;\n  }\n\n  var minDomain = getMinFromProps(props, axis);\n  var maxDomain = getMaxFromProps(props, axis);\n  var stringArray = Collection.containsStrings(categories) ? Data.getStringsFromCategories(props, axis) : [];\n  var stringMap = stringArray.length === 0 ? null : stringArray.reduce(function (memo, string, index) {\n    memo[string] = index + 1;\n    return memo;\n  }, {});\n  var categoryValues = stringMap ? categories.map(function (value) {\n    return stringMap[value];\n  }) : categories;\n  var min = minDomain !== undefined ? minDomain : Collection.getMinValue(categoryValues);\n  var max = maxDomain !== undefined ? maxDomain : Collection.getMaxValue(categoryValues);\n  var categoryDomain = getDomainFromMinMax(min, max);\n  return polar && axis === \"x\" && Math.abs(startAngle - endAngle) === 360 ? getSymmetricDomain(categoryDomain, categoryValues) : categoryDomain;\n}\n/**\n * Returns a domain from a dataset for a given axis\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @param {Array} dataset: an array of data\n * @returns {Array} the domain based on data\n */\n\nexport function getDomainFromData(props, axis, dataset) {\n  dataset = dataset || Data.getData(props);\n  var polar = props.polar,\n      _props$startAngle2 = props.startAngle,\n      startAngle = _props$startAngle2 === void 0 ? 0 : _props$startAngle2,\n      _props$endAngle2 = props.endAngle,\n      endAngle = _props$endAngle2 === void 0 ? 360 : _props$endAngle2;\n  var minDomain = getMinFromProps(props, axis);\n  var maxDomain = getMaxFromProps(props, axis);\n\n  if (dataset.length < 1) {\n    return minDomain !== undefined && maxDomain !== undefined ? getDomainFromMinMax(minDomain, maxDomain) : undefined;\n  }\n\n  var min = minDomain !== undefined ? minDomain : getExtremeFromData(dataset, axis, \"min\");\n  var max = maxDomain !== undefined ? maxDomain : getExtremeFromData(dataset, axis, \"max\");\n  var domain = getDomainFromMinMax(min, max);\n  return polar && axis === \"x\" && Math.abs(startAngle - endAngle) === 360 ? getSymmetricDomain(domain, getFlatData(dataset, axis)) : domain;\n}\n/**\n * Returns a domain in the form of a two element array given a min and max value.\n * @param {Number|Date} min: the props object\n * @param {Number|Date} max: the current axis\n * @returns {Array} the minDomain based on props\n */\n\nexport function getDomainFromMinMax(min, max) {\n  var getSinglePointDomain = function (val) {\n    // d3-scale does not properly resolve very small differences.\n    var verySmallNumber = // eslint-disable-next-line no-magic-numbers\n    val === 0 ? 2 * Math.pow(10, -10) : Math.pow(10, -10);\n    var verySmallDate = 1;\n    var minVal = val instanceof Date ? new Date(+val - verySmallDate) : +val - verySmallNumber;\n    var maxVal = val instanceof Date ? new Date(+val + verySmallDate) : +val + verySmallNumber;\n    return val === 0 ? [0, maxVal] : [minVal, maxVal];\n  };\n\n  return +min === +max ? getSinglePointDomain(max) : [min, max];\n}\n/**\n * Returns a the domain for a given axis if domain is given in props\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array|undefined} the domain based on props\n */\n\nexport function getDomainFromProps(props, axis) {\n  var minDomain = getMinFromProps(props, axis);\n  var maxDomain = getMaxFromProps(props, axis);\n\n  if (_isPlainObject(props.domain) && props.domain[axis]) {\n    return props.domain[axis];\n  } else if (Array.isArray(props.domain)) {\n    return props.domain;\n  } else if (minDomain !== undefined && maxDomain !== undefined) {\n    return getDomainFromMinMax(minDomain, maxDomain);\n  }\n\n  return undefined;\n}\n/**\n * Returns a domain for a given axis. This method forces the domain to include\n * zero unless the domain is explicitly specified in props.\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} the domain for the given axis\n */\n\nexport function getDomainWithZero(props, axis) {\n  var propsDomain = getDomainFromProps(props, axis);\n\n  if (propsDomain) {\n    return propsDomain;\n  }\n\n  var dataset = Data.getData(props);\n  var y0Min = dataset.reduce(function (min, datum) {\n    return datum._y0 < min ? datum._y0 : min;\n  }, Infinity);\n\n  var ensureZero = function (domain) {\n    if (axis === \"x\") {\n      return domain;\n    }\n\n    var defaultMin = y0Min !== Infinity ? y0Min : 0;\n    var maxDomainProp = getMaxFromProps(props, axis);\n    var minDomainProp = getMinFromProps(props, axis);\n    var max = maxDomainProp !== undefined ? maxDomainProp : Collection.getMaxValue(domain, defaultMin);\n    var min = minDomainProp !== undefined ? minDomainProp : Collection.getMinValue(domain, defaultMin);\n    return getDomainFromMinMax(min, max);\n  };\n\n  var getDomainFunction = function () {\n    return getDomainFromData(props, axis, dataset);\n  };\n\n  var formatDomainFunction = function (domain) {\n    return formatDomain(ensureZero(domain), props, axis);\n  };\n\n  return createDomainFunction(getDomainFunction, formatDomainFunction)(props, axis);\n}\n/**\n * Returns the maxDomain from props if it exists\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Number|Date|undefined} the maxDomain based on props\n */\n\nexport function getMaxFromProps(props, axis) {\n  if (_isPlainObject(props.maxDomain) && props.maxDomain[axis] !== undefined) {\n    return props.maxDomain[axis];\n  }\n\n  return typeof props.maxDomain === \"number\" || _isDate(props.maxDomain) ? props.maxDomain : undefined;\n}\n/**\n * Returns the minDomain from props if it exists\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Number|Date|undefined} the minDomain based on props\n */\n\nexport function getMinFromProps(props, axis) {\n  if (_isPlainObject(props.minDomain) && props.minDomain[axis] !== undefined) {\n    return props.minDomain[axis];\n  }\n\n  return typeof props.minDomain === \"number\" || _isDate(props.minDomain) ? props.minDomain : undefined;\n}\n/**\n * Returns a symmetrically padded domain for polar charts\n * @param {Array} domain: the original domain\n * @param {Array} values: a flat array of values corresponding to either tickValues, or data values\n * for a given dimension i.e. only x values.\n * @returns {Array} the symmetric domain\n */\n\nexport function getSymmetricDomain(domain, values) {\n  var processedData = _sortedUniq(values.sort(function (a, b) {\n    return a - b;\n  }));\n\n  var step = processedData[1] - processedData[0];\n  return [domain[0], domain[1] + step];\n}\n/**\n * Checks whether a given component can be used to calculate domain\n * @param {Component} component: a React component instance\n * @returns {Boolean} Returns true if the given component has a role included in the whitelist\n */\n\nexport function isDomainComponent(component) {\n  var getRole = function (child) {\n    return child && child.type ? child.type.role : \"\";\n  };\n\n  var role = getRole(component);\n\n  if (role === \"portal\") {\n    var children = React.Children.toArray(component.props.children);\n    role = children.length ? getRole(children[0]) : \"\";\n  }\n\n  var whitelist = [\"area\", \"axis\", \"bar\", \"boxplot\", \"candlestick\", \"errorbar\", \"group\", \"histogram\", \"line\", \"pie\", \"scatter\", \"stack\", \"voronoi\"];\n  return _includes(whitelist, role);\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}